{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenShift Quickstart","text":"<p>Welcome to the OpenShift Quickstart workshop!  This workshop is designed to provide you with a seamless development experience, whether you choose to work locally on your laptop or leverage the OpenShift DevSpaces Cloud IDE.  Both environments are equipped to help you efficiently set up and manage your development projects with ease. Follow the instructions below to get started with your preferred setup.</p>"},{"location":"#laptop","title":"Laptop","text":""},{"location":"#prerequisite-install-podman-desktop","title":"Prerequisite: Install Podman Desktop","text":"<p>Before proceeding, make sure you have Podman Desktop installed on your laptop.  You can download and install it from the official website: (https://podman-desktop.io/)[Podman Desktop].</p> <p></p>"},{"location":"#git-clone","title":"Git Clone","text":"<ol> <li>Open your terminal.</li> <li>Choose your root workspace project:<ul> <li>Decide on the directory where you want your root workspace to reside. This will be the main directory for your project files and configurations.</li> </ul> </li> <li>Navigate to the directory where you want to clone the project (e.g. <code>/projects</code>).</li> <li> <p>Run the following command to clone the Git repository:    <pre><code>cd /projects/\ngit clone https://github.com/openlab-red/openshift-quickstart.git\ngit clone https://github.com/openlab-red/openshift-quickstart-manifest.git\n</code></pre></p> </li> <li> <p>Open Visual Studio Code or your favourite IDEs:    <pre><code>code .\n</code></pre></p> </li> <li> <p>Log into your OpenShift cluster at OpenShift Console.    </p> </li> <li> <p>Navigate to the DevSpaces dashboard.    </p> </li> </ol> <p>Note: Even if working locally, having a DevSpaces namespace allows to have all necessary configuratin in place for the tutorial</p>"},{"location":"#devspaces","title":"DevSpaces","text":""},{"location":"#using-devspaces-with-devfile","title":"Using DevSpaces with Devfile","text":"<p>OpenShift DevSpaces provides a cloud-based development environment using the configuration specified in the <code>devfile.yaml</code>. </p> <p>Follow these steps to get started:</p> <ol> <li> <p>Log into your OpenShift cluster at OpenShift Console.    </p> </li> <li> <p>Navigate to the DevSpaces dashboard.    </p> </li> <li> <p>Create a new workspace by importing this repository URL:    <pre><code>https://github.com/openlab-red/openshift-quickstart.git\n</code></pre>     DevSpaces will automatically detect and use the <code>devfile.yaml</code> at the root of the project.</p> </li> <li> <p>The devfile configures:</p> <ul> <li>A developer container with ZSH shell</li> <li>Default workspace pointing to the project's VS Code workspace</li> <li>Required environment variables and configurations</li> </ul> </li> <li> <p>Once the workspace starts:</p> <ul> <li>You'll have a fully configured development environment</li> <li>All necessary tools and dependencies will be pre-installed    </li> </ul> </li> </ol> <p>Note: The devfile inherits configurations from a parent devfile that contains base developer tooling and settings.</p>"},{"location":"setup/","title":"Workshop Cluster Setup Guide","text":"<p>This guide will walk you through the process of setting up the workshop cluster using Kustomize and OpenShift CLI (oc).</p>"},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following tools installed: - OpenShift CLI (<code>oc</code>) - Kustomize - Access to an OpenShift cluster with sufficient permissions - OpenShift version 4.18.x or higher</p>"},{"location":"setup/#setup-steps","title":"Setup Steps","text":""},{"location":"setup/#1-deploy-base-cluster-configuration","title":"1. Deploy Base Cluster Configuration","text":"<p>First, deploy the base cluster configuration using Kustomize:</p> <pre><code>kustomize build cluster/base | oc apply -f -\n</code></pre> <p>This command will: - Build the Kubernetes manifests from the base configuration - Apply them directly to your OpenShift cluster</p>"},{"location":"setup/#2-deploy-tekton-tasks","title":"2. Deploy Tekton Tasks","text":"<p>Next, deploy the required Tekton tasks for the workshop:</p> <pre><code>kustomize build cluster/tekton-tasks | oc apply -f -\n</code></pre> <p>This step sets up the CI/CD pipeline components needed for the workshop environment.</p>"},{"location":"setup/#3-deploy-devspaces-configuration","title":"3. Deploy DevSpaces Configuration","text":"<p>Finally, deploy the DevSpaces configuration with nested container support:</p> <pre><code>kustomize build devspaces/overlays/nested-container | oc apply -f -\n</code></pre>"},{"location":"setup/#verification","title":"Verification","text":"<p>After running all commands, verify your setup by: 1. Checking that all resources are in the <code>Running</code> or <code>Completed</code> state 2. Ensuring no errors are present in the cluster events 3. Verifying that DevSpaces is accessible</p>"},{"location":"setup/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues: 1. Check the logs of the deployed pods 2. Verify your cluster permissions 3. Ensure all prerequisites are properly installed 4. Check the OpenShift cluster events for any error messages</p>"},{"location":"setup/#additional-notes","title":"Additional Notes","text":"<ul> <li>Make sure to run these commands in the order specified</li> <li>Wait for each step to complete before proceeding to the next</li> <li>Monitor the cluster events during deployment for any potential issues ```</li> </ul>"},{"location":"tutorials/golang/","title":"Go API with Angular Client (using Material Design)","text":"<p>This project demonstrates a simple REST API built with Go and a corresponding Angular client application. It leverages Material Design for a user-friendly interface.</p> <p>The code examples and instructions in this tutorial are located in the <code>tutorials/golang</code> directory. Ensure you are in this directory before executing the commands.</p>"},{"location":"tutorials/golang/#features","title":"Features","text":"<ul> <li>API:</li> <li>Provides endpoints, check the openapi specification.</li> <li>Uses prepared statements for secure database interaction (assuming PostgreSQL).</li> <li>Angular Client:</li> <li>Fetches messages from the API and displays them in a list.</li> <li>Allows adding new messages.</li> <li>Implements ping functionality to check API health.</li> <li>Utilizes Material Design components for a visually appealing interface.</li> </ul>"},{"location":"tutorials/golang/#launch-the-demo","title":"Launch the demo","text":""},{"location":"tutorials/golang/#setup-database","title":"Setup database","text":"<p>First time only </p> <ul> <li> <p>Open a new Terminal on the postgresql pod.</p> <p> </p> </li> <li> <p>In the terminal launch the following command to configure the database.</p> </li> </ul> <p>Password is: <code>pass</code> </p> <pre><code>  psql -d db -U user -W -f /projects/golang/backend/db/schema.sql\n</code></pre> <p>Output sample </p> <pre><code>sh-4.4$  psql -d db -U user -W -f /projects/golang/backend/db/schema.sql\nPassword: \nCREATE TABLE\nsh-4.4$ \n</code></pre> <ul> <li>You can do the same with pgadmin which is running in your workspace, open a new terminal</li> </ul> <pre><code>echo https://$(oc get route $DEVWORKSPACE_ID-pgadmin4-5050-web -o jsonpath='{ ..spec.host }')\n</code></pre> <p></p>"},{"location":"tutorials/golang/#live-coding-of-the-go-lang-dev","title":"Live Coding of the Go Lang Dev","text":"<ul> <li>The GoLang backend use <code>air</code> for live coding, so simply launch the command to start the application.</li> </ul> <pre><code>  cd backend/app\n  air\n</code></pre> <p>Click Yes if you like to expose outside of the workspace. </p> <ul> <li>Under the <code>backend/app</code> you have the OpenApi specification and you can try directly the endpoint.</li> </ul> <p></p> <p></p>"},{"location":"tutorials/golang/#live-coding-of-frontend-app","title":"Live Coding of Frontend App","text":"<ul> <li>Launch <code>npm install</code> to download all the necessary libs.</li> </ul> <pre><code>cd frontend/app\n\nnpm install\n</code></pre> <ul> <li>Launch <code>npm start</code> to start the Live Coding.</li> </ul> <pre><code>npm start\n</code></pre>"},{"location":"tutorials/golang/#test-the-application","title":"Test the application","text":"<ul> <li>From the endpoint section now you can access the frontend application.</li> </ul> <ul> <li>Click it and now you can acces the application.</li> </ul>"},{"location":"tutorials/helm%2Bkustomize/","title":"Helm and Kustomize","text":"<p>This tutorial introduces Helm and Kustomize, two powerful Kubernetes configuration management tools.  You'll learn the basics of each tool through practical exercises and see how combining them can simplify and enhance your Kubernetes deployments.</p> <p>The code examples and instructions in this tutorial are located under <code>openshift-quickstart</code> project in the <code>tutorials/helm+kustomize</code> directory.  Ensure you are in this directory before executing the commands. </p> <ol> <li> <p>Navigate to the Tutorial Directory     <pre><code># Change to the tutorials/simple directory\ncd openshift-quickstart/tutorials/helm+kustomize\n</code></pre></p> </li> <li> <p>Or open a New Terminal</p> </li> </ol>"},{"location":"tutorials/helm%2Bkustomize/#exercise-1-helm-basics","title":"Exercise 1: Helm Basics","text":""},{"location":"tutorials/helm%2Bkustomize/#objective","title":"Objective:","text":"<p>Deploy a simple application using Helm.</p>"},{"location":"tutorials/helm%2Bkustomize/#steps","title":"Steps:","text":"<ol> <li>Create a Helm Chart <pre><code>helm create myapp\n</code></pre></li> <li>Edit/Update <code>values.yaml</code> to customize your deployment:      <pre><code> image:\n   repository: registry.redhat.io/ubi9/nginx-122\n   tag: latest\n\n service:\n   type: ClusterIP\n   port: 8000\n</code></pre></li> <li> <p>Edit <code>templates/deployment.yaml</code> to add the python3 startup command:    <pre><code>spec:\n  template:\n    spec:\n      containers:\n      - name: {{ Chart.Name }}\n        command: [\"python3\"]\n        args: [\"-m\", \"http.server\"]\n</code></pre></p> </li> <li> <p>Deploy the Chart    <pre><code>helm install myapp-release ./myapp\n</code></pre></p> </li> <li>Verify Deployment    <pre><code>oc get pods\n</code></pre></li> </ol>"},{"location":"tutorials/helm%2Bkustomize/#exercise-2-kustomize-basics","title":"Exercise 2: Kustomize Basics","text":""},{"location":"tutorials/helm%2Bkustomize/#objective_1","title":"Objective:","text":"<p>Deploy the same application using Kustomize.</p>"},{"location":"tutorials/helm%2Bkustomize/#steps_1","title":"Steps:","text":"<ol> <li>Create a directory structure:      <pre><code>myapp/\n\u251c\u2500\u2500 base/\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service.yaml\n\u2502   \u2514\u2500\u2500 kustomization.yaml\n\u2514\u2500\u2500 overlays/\n    \u2514\u2500\u2500 dev/\n        \u2514\u2500\u2500 kustomization.yaml\n</code></pre></li> <li>Define Base Resources</li> <li>Populate <code>deployment.yaml</code> and <code>service.yaml</code> with basic Kubernetes manifests.</li> <li> <p>Create <code>deployment.yaml</code>:      <pre><code> apiVersion: apps/v1\n kind: Deployment\n metadata:\n   name: myapp-k\n spec:\n   replicas: 1\n   selector:\n     matchLabels:\n       app: myapp-k\n   template:\n     metadata:\n       labels:\n         app: myapp-k\n     spec:\n       containers:\n       - name: nginx\n         image: registry.redhat.io/ubi9/nginx-122:latest\n         command: [\"nginx\"]\n         args: [\"-g\", \"daemon off;\"]\n         ports:\n         - containerPort: 8080\n         resources:\n           limits:\n             cpu: \"500m\"\n             memory: \"256Mi\"\n           requests:\n             cpu: \"200m\" \n             memory: \"128Mi\"\n</code></pre></p> </li> <li> <p>Create <code>service.yaml</code>:      <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: myapp-k\nspec:\n  selector:\n    app: myapp-k\n  ports:\n  - port: 8080\n    targetPort: 8080\n  type: ClusterIP\n</code></pre></p> </li> <li> <p>In <code>overlays/dev/kustomization.yaml</code>, reference the base and apply customizations:      <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n  - ../../base\npatches:\n  - path: deployment-patch.yaml\n</code></pre></p> </li> <li> <p>Create <code>deployment-patch.yaml</code>:      <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp-k\nspec:\n  replicas: 2\n</code></pre></p> </li> <li> <p>Deploy with Kustomize**    <pre><code># The -k flag tells oc/kubectl to process the directory as a kustomization\noc apply -k overlays/dev\n</code></pre></p> </li> <li> <p>Verify Deployment**    <pre><code>oc get pods\n</code></pre></p> </li> </ol>"},{"location":"tutorials/helm%2Bkustomize/#exercise-3-using-kustomize-with-helm-charts-enable-helm","title":"Exercise 3: Using Kustomize with Helm Charts (<code>--enable-helm</code>)","text":""},{"location":"tutorials/helm%2Bkustomize/#objective_2","title":"Objective:","text":"<p>Leverage Kustomize's built-in Helm integration to directly manage Helm charts without manually rendering templates.</p>"},{"location":"tutorials/helm%2Bkustomize/#steps_2","title":"Steps:","text":"<ol> <li> <p>Create Directory Structure    <pre><code>mkdir -p helm-k/overlays/prod\n</code></pre></p> </li> <li> <p>Create a Sample Helm Chart    <pre><code># Create charts directory\nmkdir -p helm-k/overlays/prod/charts\ncd helm-k/overlays/prod/charts\n\n# Create a sample Helm chart\nhelm create myapp\n\n# Return to the base directory\ncd ../../..\n</code></pre></p> </li> </ol> <p>This will create a basic Helm chart structure with default templates and values.</p> <ol> <li> <p>Define Kustomization with Helm Chart    Create a <code>kustomization.yaml</code> file in <code>helm-k/overlays/prod</code>:    <pre><code> apiVersion: kustomize.config.k8s.io/v1beta1\n kind: Kustomization\n\n helmGlobals:\n   chartHome: ./charts\n helmCharts:\n   - name: myapp\n     releaseName: myapp-prod\n     namespace: prod\n     valuesInline:\n       replicaCount: 2\n</code></pre></p> </li> <li> <p>Build Using Kustomize with Helm Enabled and check the replicas    <pre><code>kustomize build --enable-helm helm-k/overlays/prod |grep replicas\n</code></pre></p> </li> </ol>"},{"location":"tutorials/helm%2Bkustomize/#explanation","title":"Explanation:","text":"<ul> <li>The <code>--enable-helm</code> flag allows Kustomize to directly process Helm charts, simplifying the workflow by eliminating the need to manually run <code>helm template</code>.</li> <li>Inline values (<code>valuesInline</code>) provide a convenient way to customize Helm chart parameters directly within the Kustomize configuration.</li> </ul>"},{"location":"tutorials/java/","title":"Java Stack","text":"<p>Welcome to the Java Stack repository! This repository contains sample projects that demonstrate the use of popular Java frameworks and tools. Each project is designed to help you understand the basics of building, running, and debugging Java applications using different frameworks.</p>"},{"location":"tutorials/java/#projects-included","title":"Projects Included","text":"<ol> <li>Hello World Maven Project</li> <li>A foundational Java application that outputs \"Hello, World!\" to demonstrate the basics of using Maven.</li> <li> <p>Maven Documentation</p> </li> <li> <p>Quarkus Hello World Application</p> </li> <li>A simple application leveraging Quarkus, a high-performance Java framework for cloud-native applications.</li> <li>Quarkus Documentation</li> <li> <p>Quarkus Guides</p> </li> <li> <p>Spring Boot Sample Application</p> </li> <li>A sample application using Spring Boot, a powerful framework for building production-ready applications.</li> <li>Spring Boot Documentation</li> <li>VSCode Java Documentation</li> </ol>"},{"location":"tutorials/java/#how-to-use","title":"How to Use","text":"<p>Each project comes with its own index file that provides detailed instructions on how to build, run, and debug the application. You can find these instructions in the respective project directories:</p> <ul> <li>Hello World Maven Project</li> <li>Quarkus Hello World Application</li> <li>Spring Boot Sample Application </li> </ul> <p>This repository is a great starting point for anyone looking to explore Java development with different frameworks. If you encounter any issues, please refer to the documentation linked above or seek help from the community.</p>"},{"location":"tutorials/java/helloworld/","title":"Hello World Maven Project","text":"<p>This project is a foundational Java application that outputs \"Hello, World!\" to demonstrate the basics of using Maven for building and managing Java projects.</p>"},{"location":"tutorials/java/helloworld/#tutorial-build-run-and-debug-with-visual-studio-code","title":"Tutorial: Build, Run, and Debug with Visual Studio Code","text":""},{"location":"tutorials/java/helloworld/#step-1-build-the-project","title":"Step 1: Build the Project","text":"<ol> <li>Open the terminal in VSCode (<code>Terminal -&gt; New Terminal</code>).</li> <li>Run the following command to build the project:</li> </ol> <pre><code> cd helloworld\n mvn clean install\n</code></pre>"},{"location":"tutorials/java/helloworld/#step-4-launch-the-application","title":"Step 4: Launch the Application","text":"<ol> <li>Navigate to the <code>Run and Debug</code> view by clicking on the play icon on the sidebar or pressing <code>Ctrl+Shift+D</code>.</li> <li>Select the <code>HelloWorld</code> configuration from the dropdown.</li> <li>Click the green play button to start the application.</li> </ol>"},{"location":"tutorials/java/helloworld/#step-5-debug-the-application","title":"Step 5: Debug the Application","text":"<ol> <li>Set breakpoints in your code by clicking in the gutter next to the line numbers.</li> <li>Use the <code>Run and Debug</code> view to start debugging with the <code>HelloWorld</code> configuration.</li> <li>The application will stop at your breakpoints, allowing you to inspect variables and step through the code.</li> </ol>"},{"location":"tutorials/java/helloworld/#alternative-using-command-line","title":"Alternative: Using Command Line","text":""},{"location":"tutorials/java/helloworld/#step-1-build-the-project-by-cmd","title":"Step 1: Build the Project by cmd","text":"<ol> <li>Open a terminal and navigate to the <code>helloworld</code> project directory.</li> <li>Run the following command to build the project:</li> </ol> <pre><code>mvn clean package\n</code></pre>"},{"location":"tutorials/java/helloworld/#step-2-run-the-application","title":"Step 2: Run the Application","text":"<p>After building, you can run the application using the <code>java -jar</code> command:</p> <pre><code>java -jar target/helloworld-1.0.0-SNAPSHOT.jar\n</code></pre>"},{"location":"tutorials/java/quarkus/","title":"Quarkus Hello World Application","text":"<p>Welcome to the Quarkus Hello World Application! This project leverages Quarkus, a high-performance Java framework designed for modern cloud-native applications. In this guide, you'll learn how to build, run, and debug a straightforward \"Hello World\" application using Visual Studio Code, making the most of Quarkus's capabilities.</p>"},{"location":"tutorials/java/quarkus/#building-the-application","title":"Building the Application","text":"<p>To build the application, use the following Maven command:</p> <pre><code>cd quarkus\nmvn clean package\n</code></pre> <p>This command will compile the project and package it into a JAR file located in the <code>target/quarkus-app/</code> directory.</p>"},{"location":"tutorials/java/quarkus/#running-the-application","title":"Running the Application","text":"<p>You can run the application like normal java app.</p> <pre><code>java -jar target/quarkus-app/quarkus-run.jar\n</code></pre> <p>Or you can run your application in development mode, which enables live coding, using:</p> <pre><code>mvn quarkus:dev\n</code></pre> <p>Expose the endpoint and access the application.</p> <p> </p>"},{"location":"tutorials/java/quarkus/#debugging-with-vscode","title":"Debugging with VSCode","text":"<p>It is already defined in the project. </p> <ol> <li>Configure Launch Settings:    Create a <code>launch.json</code> file in the <code>.vscode</code> directory with the following configuration:</li> </ol> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"java\",\n      \"name\": \"Quarkus Debug (Attach)\",\n      \"request\": \"attach\",\n      \"hostName\": \"localhost\",\n      \"port\": 5005\n    }\n  ]\n}\n</code></pre> <ol> <li>Start the Application in Debug Mode:    Run the application with debugging enabled:</li> </ol> <pre><code>mvn quarkus:dev\n</code></pre> <ol> <li>Attach the Debugger</li> </ol> <p>In VSCode, go to the Run and Debug view, and select \"Quarkus Debug (Attach)\" to start debugging.</p> <p></p>"},{"location":"tutorials/java/quarkus/#packaging-the-application","title":"Packaging the Application","text":"<p>To package the application execute:</p> <pre><code>mvn package\n</code></pre> <p>Run the packaged application using:</p> <pre><code>java -jar target/quarkus-app/quarkus-run.jar\n</code></pre>"},{"location":"tutorials/java/quarkus/#creating-a-native-executable","title":"Creating a Native Executable","text":"<p>You can create a native executable using:</p> <pre><code>mvn package -Pnative\n</code></pre> <p>Run the native executable with:</p> <pre><code>./target/quarkus-1.0.0-SNAPSHOT-runner -Dquarkus.http.port=8081\n</code></pre>"},{"location":"tutorials/java/quarkus/#building-the-container","title":"Building the Container","text":"<p>To build a container for your Quarkus application, follow these steps:</p>"},{"location":"tutorials/java/quarkus/#deploy-external-postgresql-database","title":"Deploy external postgresql database","text":"<p>To deploy it, you can simply run the Task <code>099 - Install Postgres with OpenShift</code> from the Task Manager.</p>"},{"location":"tutorials/java/quarkus/#steps","title":"Steps","text":"<ol> <li>Ensure the Application is Packaged:    Before building the Docker image, make sure your application is packaged. You can do this by running:</li> </ol> <pre><code>mvn package -Dquarkus.profile=prod\n</code></pre> <ol> <li>Build the Image:    Use the following command to build the image. This command uses the Dockerfile located at <code>src/main/docker/Dockerfile.jvm</code>:</li> </ol> <pre><code>podman build -f src/main/docker/Dockerfile.jvm -t quarkus:latest .\n</code></pre> <ol> <li>Run the Docker Container:    Once the image is built, you can run the container using:</li> </ol> <pre><code>podman_run quarkus:latest -p 8080:8080 \n</code></pre> <ol> <li>Deploy with the helm chart:</li> </ol> <pre><code>podman tag quarkus:latest quay.io/mmascia/stack-java/quarkus:latest\npodman push quay.io/mmascia/stack-java/quarkus:latest\ncd ..\nhelm upgrade --install quarkus helm/java-app\n</code></pre> <p>These steps will help you build and run your Quarkus application in a container, allowing for easy deployment and testing.</p>"},{"location":"tutorials/java/quarkus/#database","title":"Database","text":"<p>The Quarkus application supports multiple database configurations. You can run the application with different databases using the following methods:</p>"},{"location":"tutorials/java/quarkus/#prerequisites-for-database-containers","title":"Prerequisites for Database Containers","text":"<p>Before running the application with a specific database profile, ensure that the respective database container is up and running. You can use the following commands to start the database containers:</p> <ul> <li>PostgreSQL: </li> </ul> <p>Note: PostgreSQL is already running as a sidecar container in the workspace. If you need to start it manually, execute the following command:</p> <ul> <li>MySQL:    To start the MySQL container, execute the following command:</li> </ul> <pre><code>podman run --name mysql -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=db -p 3306:3306 registry.redhat.io/rhel8/mysql-80:latest\n</code></pre> <ul> <li>MongoDB:    To start the MongoDB container, execute the following command:</li> </ul> <pre><code>podman run --name mongodb -v /tmp/:/bitnami -e MONGODB_ROOT_USER=user -e MONGODB_ROOT_PASSWORD=pass -e MONGODB_REPLICA_SET_MODE=primary -e MONGODB_REPLICA_SET_NAME=rs0 -e MONGODB_REPLICA_SET_KEY=replicakey123456 -e MONGODB_DATABASE=db -p 27017:27017 docker.io/bitnami/mongodb:latest\n</code></pre> <p>Ensure that the respective database container is running before starting the application with the desired profile.</p>"},{"location":"tutorials/java/quarkus/#launching-the-application","title":"Launching the Application","text":"<p>To launch the Quarkus application with a specific database profile, use the following commands:</p> <ul> <li>PostgreSQL (Default):   Run the application with the default PostgreSQL profile:</li> </ul> <pre><code>mvn quarkus:dev\n</code></pre> <ul> <li>MySQL:   To run the application with MySQL, specify the MySQL profile:</li> </ul> <pre><code>mvn quarkus:dev -Dquarkus.profile=mysql\n</code></pre> <ul> <li>MongoDB:   To run the application with MongoDB, specify the MongoDB profile:</li> </ul> <pre><code>mvn quarkus:dev -Dquarkus.profile=mongodb\n</code></pre> <p>These commands will start the Quarkus application in development mode with the specified database configuration.</p>"},{"location":"tutorials/java/quarkus/#additional-resources","title":"Additional Resources","text":"<ul> <li>Quarkus Official Documentation</li> <li>Quarkus Guides</li> </ul> <p>This guide should help you get started with building, running, and debugging a Quarkus application using VSCode. If you encounter any issues, refer to the Quarkus documentation or seek help from the community.</p>"},{"location":"tutorials/java/springboot/","title":"Spring Boot Sample Application","text":"<p>Welcome to the Spring Boot Sample Application! This project leverages Spring Boot, a powerful Java framework for building production-ready applications. In this guide, you'll learn how to build, run, and debug a Spring Boot application using Visual Studio Code, making the most of Spring Boot's capabilities.</p>"},{"location":"tutorials/java/springboot/#building-the-application","title":"Building the Application","text":"<p>To build the application, use the following Maven command:</p> <pre><code>cd springboot\nmvn clean package\n</code></pre> <p>This command will compile the project and package it into a JAR file located in the <code>target/</code> directory.</p>"},{"location":"tutorials/java/springboot/#running-the-application","title":"Running the Application","text":"<p>You can run the application like normal java app.</p> <pre><code>java -jar target/boot-0.0.1-SNAPSHOT.jar\n</code></pre> <p>Or you can run your application in development mode, which enables live coding, using:</p> <pre><code>mvn spring-boot:run\n</code></pre> <p>Expose the endpoint and access the application.</p> <p></p>"},{"location":"tutorials/java/springboot/#debugging-with-vscode","title":"Debugging with VSCode","text":"<p>It is already defined in the project. </p> <ol> <li>Run in VSCode:</li> <li>Open the project in VSCode.</li> <li>Navigate to the <code>BootApplication.java</code> file.</li> <li>Click on the <code>Run</code> button above the <code>main</code> method or use the <code>Run</code> menu.</li> </ol>"},{"location":"tutorials/java/springboot/#debugging-the-application","title":"Debugging the Application","text":"<ol> <li>Debug in VSCode:</li> <li>Set breakpoints in your Java files.</li> <li>Open the <code>Run and Debug</code> panel in VSCode (Ctrl+Shift+D).</li> <li>Click on <code>Run and Debug</code> and select <code>Java</code> environment.</li> <li>The application will start in debug mode, and execution will pause at your breakpoints.</li> </ol>"},{"location":"tutorials/java/springboot/#building-the-container","title":"Building the Container","text":"<p>To build a container for your Quarkus application, follow these steps:</p>"},{"location":"tutorials/java/springboot/#deploy-external-postgresql-database","title":"Deploy external postgresql database","text":"<p>To deploy it, you can simply run the Task <code>099 - Install Postgres with OpenShift</code> from the Task Manager.</p>"},{"location":"tutorials/java/springboot/#steps","title":"Steps","text":"<ol> <li>Ensure the Application is Packaged:    Before building the Docker image, make sure your application is packaged. You can do this by running:</li> </ol> <pre><code>mvn package\n</code></pre> <ol> <li>Build the Image:    Use the following command to build the image. This command uses the Dockerfile located at <code>src/main/docker/Dockerfile.jvm</code>:</li> </ol> <pre><code>podman build -f src/main/docker/Dockerfile.jvm -t boot:latest .\n</code></pre> <ol> <li>Run the Docker Container:    Once the image is built, you can run the container using:</li> </ol> <pre><code>podman_run boot:latest -p 8080:8080 \n</code></pre> <ol> <li>Deploy with the helm chart:</li> </ol> <pre><code>podman tag boot:latest quay.io/mmascia/stack-java/boot:latest\npodman push quay.io/mmascia/stack-java/boot:latest\ncd ..\nhelm upgrade --install boot helm/java-app -f helm/java-app/values-boot.yaml\n</code></pre> <p>These steps will help you build and run your Spring Boot application in a container, allowing for easy deployment and testing.</p> <p>// ... existing content ...</p>"},{"location":"tutorials/java/springboot/#database","title":"Database","text":"<p>The application supports multiple database configurations through Spring profiles. You can run the application with different databases using the following methods:</p>"},{"location":"tutorials/java/springboot/#prerequisites-for-database-containers","title":"Prerequisites for Database Containers","text":"<p>Before running the application with a specific database profile, ensure that the respective database container is up and running. You can use the following commands to start the database containers:</p> <ul> <li>PostgreSQL: </li> </ul> <p>Note: PostgreSQL is already running as a sidecar container in the workspace. If you need to start it manually, execute the following command:</p> <ul> <li>MySQL:    To start the MySQL container, execute the following command:</li> </ul> <pre><code>podman run --name mysql -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=db -p 3306:3306 registry.redhat.io/rhel8/mysql-80:latest\n</code></pre> <ul> <li>MongoDB:    To start the MongoDB container, execute the following command:</li> </ul> <pre><code>podman run --name mongodb -v /tmp/:/bitnami -e MONGODB_ROOT_USER=user -e MONGODB_ROOT_PASSWORD=pass -e MONGODB_REPLICA_SET_MODE=primary -e MONGODB_REPLICA_SET_NAME=rs0 -e MONGODB_REPLICA_SET_KEY=replicakey123456 -e MONGODB_DATABASE=db -p 27017:27017 docker.io/bitnami/mongodb:latest\n</code></pre> <p>Ensure that the respective database container is running before starting the application with the desired profile.</p>"},{"location":"tutorials/java/springboot/#postgresql-default","title":"PostgreSQL (Default)","text":"<p>The default profile uses PostgreSQL. Run the application with either:</p> <pre><code>mvn spring-boot:run\n</code></pre> <p>Or explicitly specify the PostgreSQL profile:</p> <pre><code>mvn spring-boot:run\n</code></pre>"},{"location":"tutorials/java/springboot/#mysql","title":"MySQL","text":"<p>To run the application with MySQL:</p> <pre><code>mvn spring-boot:run -Dspring-boot.run.profiles=mysql\n</code></pre>"},{"location":"tutorials/java/springboot/#mongodb","title":"MongoDB","text":"<p>To run the application with MongoDB:</p> <pre><code>mvn spring-boot:run -Dspring-boot.run.profiles=mongodb\n</code></pre>"},{"location":"tutorials/java/springboot/#additional-resources","title":"Additional Resources","text":"<ul> <li>Spring Boot Documentation</li> <li>VSCode Java Documentation</li> </ul>"},{"location":"tutorials/java/springboot/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure all dependencies are correctly installed.</li> <li>Check the <code>pom.xml</code> for any missing dependencies or plugins.</li> </ul>"},{"location":"tutorials/js/","title":"NodeJs Express API with Angular Client (using Material Design)","text":"<p>This project demonstrates a simple REST API built with Express NodeJS and a corresponding Angular client application. It leverages Material Design for a user-friendly interface.</p>"},{"location":"tutorials/js/#features","title":"Features","text":"<ul> <li>API:</li> <li>Provides endpoints, check the openapi specification.</li> <li>Uses prepared statements for secure database interaction (assuming PostgreSQL).</li> <li>Angular Client:</li> <li>Fetches messages from the API and displays them in a list.</li> <li>Allows adding new messages.</li> <li>Implements ping functionality to check API health.</li> <li>Utilizes Material Design components for a visually appealing interface.</li> </ul>"},{"location":"tutorials/js/#launch-the-demo","title":"Launch the demo","text":""},{"location":"tutorials/js/#setup-database","title":"Setup database","text":"<p>First time only </p> <ul> <li> <p>Open a new Terminal on the postgresql pod.</p> <p> </p> </li> <li> <p>In the terminal launch the following command to configure the database.</p> </li> </ul> <p>Password is: <code>pass</code> </p> <pre><code>  psql -d db -U user -W -f /projects/js/backend/db/schema.sql\n</code></pre> <p>Output sample </p> <pre><code>sh-4.4$  psql -d db -U user -W -f /projects/js/backend/db/schema.sql\nPassword: \nCREATE TABLE\nsh-4.4$ \n</code></pre> <ul> <li>You can do the same with pgadmin which is running in your workspace, open a new terminal</li> </ul> <pre><code>echo https://$(oc get route $DEVWORKSPACE_ID-pgadmin4-5050-web -o jsonpath='{ ..spec.host }')\n</code></pre> <p></p>"},{"location":"tutorials/js/#live-coding-of-the-nodejs-server","title":"Live Coding of the NodeJs server","text":"<ul> <li>Launch <code>npm install</code> to download all the necessary libs.</li> </ul> <pre><code>cd backend/app\n\nnpm install\n</code></pre> <ul> <li>The nodejs backend use <code>nodemon</code> for live coding, so simply launch the command to start the application.</li> </ul> <pre><code>  cd backend/app\n  npm run startdev\n</code></pre> <p>Click Yes if you like to expose outside of the workspace. </p> <ul> <li>Under the <code>backend/app</code> you have the OpenApi specification and you can try directly the endpoint.</li> </ul> <p></p> <p></p>"},{"location":"tutorials/js/#live-coding-of-frontend-app","title":"Live Coding of Frontend App","text":"<ul> <li>Launch <code>npm install</code> to download all the necessary libs.</li> </ul> <pre><code>cd frontend/app\n\nnpm install\n</code></pre> <ul> <li>Launch <code>npm start</code> to start the Live Coding.</li> </ul> <pre><code>npm start\n</code></pre>"},{"location":"tutorials/js/#test-the-application","title":"Test the application","text":"<ul> <li>From the endpoint section now you can access the frontend application.</li> </ul> <ul> <li>Click it and now you can acces the application.</li> </ul>"},{"location":"tutorials/networkpolicy/","title":"Network Policy","text":""},{"location":"tutorials/networkpolicy/#tutorial","title":"Tutorial","text":"<p>The code examples and instructions in this tutorial are located under <code>openshift-quickstart</code> project in the <code>tutorials/networkpolicy</code> directory.  Ensure you are in this directory before executing the commands. </p> <ol> <li> <p>Navigate to the Tutorial Directory     <pre><code># Change to the tutorials/simple directory\ncd openshift-quickstart/tutorials/networkpolicy\n</code></pre></p> </li> <li> <p>Or open a New Terminal</p> </li> </ol>"},{"location":"tutorials/networkpolicy/#steps","title":"Steps","text":"<p>Note: At this point, you should have at least one Python pods up and running in your namespace.</p> <ol> <li> <p>Deploy a new Python pod with a different name and labels to test network policies.</p> <p>Use the following YAML configuration: <pre><code>---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: python-server-second\n  labels:\n    app: python-server-second\nspec:\n  securityContext:\n    runAsNonRoot: true\n    seccompProfile:\n      type: RuntimeDefault\n  containers:\n  - name: python-server-container\n    image: registry.redhat.io/ubi9/python-312\n    ports:\n    - containerPort: 8000\n    command: [\"python3\", \"-m\", \"http.server\"]\n    resources:\n      limits:\n        cpu: \"0.5\"\n        memory: \"512Mi\"\n      requests:\n        cpu: \"0.2\"\n        memory: \"256Mi\"\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [\"ALL\"]\n      readOnlyRootFilesystem: true\n    livenessProbe:\n      httpGet:\n        path: /\n        port: 8000\n      initialDelaySeconds: 3\n      periodSeconds: 3\n</code></pre> 2. Expose the <code>python-server-second</code> pod with a service to enable network communication.</p> <p>Use the following YAML configuration: <pre><code>---\napiVersion: v1\nkind: Service\nmetadata:\n  name: python-server-second-service\nspec:\n  selector:\n    app: python-server-second\n  ports:\n    - protocol: TCP\n      port: 8000\n      targetPort: 8000\n</code></pre></p> </li> <li> <p>Verify that all communication is allowed within the namespace.</p> <p>Execute the following command to test connectivity to the <code>python-server-second-service</code> service. <pre><code>oc rsh python-server-pod\ncurl -I http://python-server-second-service:8000\nexit\n</code></pre></p> <p>Use this command to test connectivity to the <code>python-server-service</code> on port 8000. <pre><code>oc rsh python-server-second\ncurl -I http://python-server-service:8000\n</code></pre></p> </li> <li> <p>Restrict the traffic to your <code>python-server-service</code> service by applying a deny policy.     <pre><code>oc create -f deny.yaml\n</code></pre></p> </li> <li> <p>Check the connectivity from the second Python pod to ensure the deny policy is in effect.     <pre><code>curl -I http://python-server-service:8000 -v\n</code></pre></p> </li> <li> <p>Re-enable specific traffic to the <code>devspaces-userX</code> namespace by applying an allow policy.     <pre><code>oc create -f allow.yaml\n</code></pre></p> </li> <li> <p>Verify that the allow policy is functioning correctly by testing connectivity again.</p> <p>Execute: <pre><code>curl -I http://python-server-service:8000\n</code></pre></p> </li> </ol>"},{"location":"tutorials/networkpolicy/#exercises","title":"Exercises","text":""},{"location":"tutorials/networkpolicy/#exercise-1-a-third-pod","title":"Exercise 1: A third pod","text":"<ol> <li> <p>Deploy a new Python pod named <code>python-server-third</code> to test network policies.</p> <p>Use the following YAML configuration: <pre><code>---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: python-server-third\n  labels:\n    app: python-server-third\nspec:\n  securityContext:\n    runAsNonRoot: true\n    seccompProfile:\n      type: RuntimeDefault\n  containers:\n  - name: python-server-container\n    image: registry.redhat.io/ubi9/python-312\n    ports:\n    - containerPort: 8000\n    command: [\"python3\", \"-m\", \"http.server\"]\n    resources:\n      limits:\n        cpu: \"0.5\"\n        memory: \"512Mi\"\n      requests:\n        cpu: \"0.2\"\n        memory: \"256Mi\"\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [\"ALL\"]\n      readOnlyRootFilesystem: true\n    livenessProbe:\n      httpGet:\n        path: /\n        port: 8000\n      initialDelaySeconds: 3\n      periodSeconds: 3\n</code></pre></p> </li> <li> <p>Test the connectivity from the <code>python-server-third</code> pod to ensure the deny policy is in effect.     <pre><code>oc rsh python-server-third\ncurl -I http://python-server-service:8000 -v\nexit\n</code></pre></p> </li> <li> <p>Allow communication to the <code>python-server-third</code> pod by applying a new allow policy.</p> <p>Use the following YAML configuration: <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-third-pod-communication\nspec:\n  podSelector:\n    matchLabels:\n      app: python-server\n  policyTypes:\n  - Ingress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: python-server-third\n</code></pre></p> </li> <li> <p>Enable the new allow policy to permit traffic from the <code>python-server-third</code> pod.     <pre><code>oc create -f allow-third-pod.yaml\n</code></pre></p> </li> <li> <p>Test connectivity again to ensure the allow policy is functioning correctly.</p> <p><pre><code>oc rsh python-server-third\ncurl -I http://python-server-service:8000\nexit\n</code></pre> I'll help you create another exercise that builds upon the network policy concepts shown in the tutorial. Here's a suggested exercise:</p> </li> </ol>"},{"location":"tutorials/networkpolicy/#exercise-2-multi-tier-application-network-policies","title":"Exercise 2: Multi-tier Application Network Policies","text":"<p>This exercise will simulate a more realistic scenario with a multi-tier application setup, helping users understand how to implement network policies for different application layers.</p> <ol> <li> <p>Deploy a three-tier application setup with the following components:</p> <p>a. Frontend Pod (Web Server): <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: frontend-pod\n  labels:\n    tier: frontend\n    app: multi-tier-app\nspec:\n  securityContext:\n    runAsNonRoot: true\n    seccompProfile:\n      type: RuntimeDefault\n  containers:\n  - name: frontend-container\n    image: registry.redhat.io/ubi9/python-312\n    ports:\n    - containerPort: 8080\n    command: [\"python3\", \"-m\", \"http.server\", \"8080\"]\n    resources:\n      limits:\n        cpu: \"0.5\"\n        memory: \"512Mi\"\n      requests:\n        cpu: \"0.2\"\n        memory: \"256Mi\"\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [\"ALL\"]\n</code></pre></p> <p>b. API Pod (Application Layer):   <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: api-pod\n  labels:\n    tier: api\n    app: multi-tier-app\nspec:\n  securityContext:\n    runAsNonRoot: true\n    seccompProfile:\n      type: RuntimeDefault\n  containers:\n  - name: api-container\n    image: registry.redhat.io/ubi9/python-312\n    ports:\n    - containerPort: 5000\n      name: api\n    command: [\"python3\", \"-m\", \"http.server\", \"5000\"]\n    resources:\n      limits:\n        cpu: \"0.5\"\n        memory: \"512Mi\"\n      requests:\n        cpu: \"0.2\"\n        memory: \"256Mi\"\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [\"ALL\"]\n</code></pre></p> <p>c. Database Pod: <pre><code>---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: db-config\n  labels:\n    tier: database\n    app: multi-tier-app\ndata:\n  POSTGRESQL_USER: user\n  POSTGRESQL_PASSWORD: pass\n  POSTGRESQL_ROOT_PASSWORD: root\n  POSTGRESQL_DATABASE: db\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: db-pod\n  labels:\n    tier: database\n    app: multi-tier-app\nspec:\n  securityContext:\n    runAsNonRoot: true\n    seccompProfile:\n      type: RuntimeDefault\n  containers:\n  - name: db-container\n    image: registry.redhat.io/rhel9/postgresql-16:latest\n    ports:\n    - containerPort: 5432\n    envFrom:\n      - configMapRef:\n          name: db-config\n    volumeMounts:\n      - mountPath: /var/lib/pgsql/data\n        name: postgresdata\n    resources:\n      limits:\n        cpu: \"0.5\"\n        memory: \"512Mi\"\n      requests:\n        cpu: \"0.2\"\n        memory: \"256Mi\"\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [\"ALL\"]\n  volumes:\n    - name: postgresdata\n      emptyDir: {}\n</code></pre></p> </li> <li> <p>Create corresponding services for each pod:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  selector:\n    tier: frontend\n  ports:\n    - protocol: TCP\n      port: 8080\n      targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: api-service\n  labels:\n    tier: api\nspec:\n  selector:\n    tier: api\n  ports:\n    - protocol: TCP\n      port: 5000\n      targetPort: 5000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: db-service\nspec:\n  selector:\n    tier: database\n  ports:\n    - protocol: TCP\n      port: 5432\n      targetPort: 5432\n</code></pre> </li> <li> <p>Tasks:</p> </li> </ol> <p>a. Create a network policy that:       - Allows frontend to communicate only with the API layer       - Allows API layer to communicate only with the database       - Denies all other traffic between pods       - Allows external traffic only to the frontend</p> <p>b. Test the connectivity between different layers:       - Test frontend to API communication       - Test frontend to database communication (should fail)       - Test API to database communication       - Test external access to frontend</p> <ol> <li>First, let's create a default deny policy to ensure all traffic is blocked by default:</li> </ol> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny-all\nspec:\n  podSelector:\n    matchLabels:\n      app: multi-tier-app\n  policyTypes:\n  - Ingress\n  - Egress\n</code></pre> <ol> <li>Frontend Network Policy (allows incoming external traffic and outgoing to API):</li> </ol> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: frontend-policy\nspec:\n  podSelector:\n    matchLabels:\n      tier: frontend\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - {}  # Allows all incoming traffic\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              tier: api\n      ports:\n        - port: 5000\n</code></pre> <ol> <li>API Layer Network Policy (allows frontend traffic and connection to database):</li> </ol> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-policy\nspec:\n  podSelector:\n    matchLabels:\n      tier: api\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          tier: frontend\n    ports:\n    - protocol: TCP\n      port: 5000\n  egress: \n  - {}\n</code></pre> <ol> <li>Database Network Policy (only allows API layer access):</li> </ol> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: database-policy\nspec:\n  podSelector:\n    matchLabels:\n      tier: database\n  policyTypes:\n  - Ingress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          tier: api\n    ports:\n    - protocol: TCP\n      port: 5432\n</code></pre> <ol> <li>Testing Commands:</li> </ol> <pre><code># Test frontend to API communication (should succeed)\noc rsh frontend-pod\ncurl -I http://api-service:5000\nexit\n\n# Test frontend to database communication (should fail)\noc rsh frontend-pod\ncurl -I http://db-service:5432\nexit\n\n# Test API to database communication (should succeed)\noc rsh api-pod\ncurl -I http://db-service:5432\nexit\n</code></pre> <ol> <li> <p>Expected Results:</p> </li> <li> <p>Frontend pod should only be able to communicate with the API service</p> </li> <li>API pod should only be able to communicate with the database service</li> <li>Database pod should only accept connections from the API service</li> <li>Monitoring pod should be able to access all services</li> <li>Any other communication attempts should fail</li> </ol>"},{"location":"tutorials/pipeline/","title":"Pipeline Setup","text":"<p>This tutorial will guide you through the process of setting up and executing a pipeline using the provided Helm chart. We will cover creating a pipeline and PVC, launching a PipelineRun, and setting up event listeners and triggers.</p>"},{"location":"tutorials/pipeline/#steps","title":"Steps","text":""},{"location":"tutorials/pipeline/#1-install-the-pipeline-using-helm","title":"1. Install the Pipeline using Helm","text":"<p>First, we need to install the pipeline using the Helm chart. The release name should be the type of the pipeline (e.g., <code>java</code>, <code>golang</code>, <code>nodejs</code>), and the target namespace should be your user namespace (<code>user1</code>) or <code>devspaces-user1</code> if using DevSpaces.</p>"},{"location":"tutorials/pipeline/#15-link-the-registry-credentials-to-the-pipeline-service-account","title":"1.5. Link the Registry Credentials to the Pipeline Service Account","text":"<p>Before launching the pipeline, ensure that the pipeline service account has the necessary credentials to pull images from the registry. Use the following command to link the <code>registry-credentials</code> secret to the <code>pipeline</code> service account:</p> <pre><code>oc secrets link --for=mount pipeline registry-credentials\n</code></pre> <ol> <li>Install the Helm Chart:</li> </ol> <p>Use the following command to install the Helm chart. Replace <code>&lt;pipeline-type&gt;</code> with <code>java</code>, <code>golang</code>, or <code>nodejs</code>, and <code>&lt;namespace&gt;</code> with <code>user1</code> or <code>devspaces-user1</code>.</p> <pre><code>cd gitops/pipeline\n\nhelm install &lt;pipeline-type&gt; helm/pipeline --namespace &lt;namespace&gt;\n</code></pre>"},{"location":"tutorials/pipeline/#2-launch-the-pipelinerun","title":"2. Launch the PipelineRun","text":"<p>To execute the pipeline, we need to create a PipelineRun using the OpenShift UI.</p> <ol> <li> <p>Create the PipelineRun:</p> </li> <li> <p>Navigate to the OpenShift Console and log in with your credentials.</p> </li> <li>Go to the \"Pipelines\" section in your project.</li> <li>Click on the target pipeline from the list.</li> <li> <p>Click Actions and \"Start\" button.</p> </li> <li> <p>Select Workspaces:</p> </li> </ol> <p>Before starting the PipelineRun, ensure that you have selected the appropriate workspaces and PVCs. This is crucial for the pipeline to access necessary resources and credentials.</p> <ul> <li> <p>Select Workspaces:</p> <ul> <li>Ensure the following workspaces are selected:</li> <li><code>&lt;pipeline-type&gt;-ws</code></li> <li><code>&lt;pipeline-type&gt;-resource-ws</code></li> <li><code>&lt;pipeline-type&gt;-dockerconfig</code></li> <li><code>&lt;pipeline-type&gt;-git-credentials</code></li> </ul> </li> <li> <p>Select PVCs:</p> <ul> <li>Ensure the following PVCs are selected:</li> <li><code>&lt;pipeline-type&gt;-ws</code> (replace with actual PVC name)</li> <li><code>&lt;pipeline-type&gt;-resource-ws</code> (replace with actual PVC name)</li> </ul> </li> <li> <p>Link Docker and GitHub Credentials:</p> <ul> <li>Ensure that the Docker and GitHub credentials are linked to the pipeline service account:</li> <li><code>registry-credentials</code> for Docker</li> <li><code>git-credentials</code> for GitHub</li> </ul> </li> </ul> <p>After selecting the workspaces, PVCs, and linking the credentials, proceed to the next step.</p> <ol> <li>Click \"Start\":</li> </ol> <p>Once all selections are made, click the \"Start\" button to initiate the PipelineRun.</p>"},{"location":"tutorials/python/","title":"Deploying and Testing a Python server","text":""},{"location":"tutorials/python/#tutorial","title":"Tutorial","text":"<p>The code examples and instructions in this tutorial are located under <code>openshift-quickstart</code> project in the <code>tutorials/python</code> directory.  Ensure you are in this directory before executing the commands. </p> <ol> <li> <p>Navigate to the Tutorial Directory     <pre><code># Change to the tutorials/simple directory\ncd openshift-quickstart/tutorials/python\n</code></pre></p> </li> <li> <p>Or open a New Terminal</p> </li> </ol>"},{"location":"tutorials/python/#building-the-container-image","title":"Building the Container Image","text":"<ol> <li>Build the Container Image:    Use the following command to build the container image for the Python server:    <pre><code>podman build -t python-server:latest .\n</code></pre></li> </ol>"},{"location":"tutorials/python/#running-the-container","title":"Running the Container","text":"<ol> <li> <p>Run the Container:    Start the container using the image you just built:    <pre><code>podman run python-server:latest\n</code></pre></p> </li> <li> <p>Verify the Container is Running:    Check the status of the running container with:    <pre><code>podman ps\n</code></pre></p> </li> </ol>"},{"location":"tutorials/python/#testing-the-server","title":"Testing the Server","text":"<ol> <li> <p>Test the Server:    Ensure the server is responding by executing:    <pre><code>curl http://localhost:8000\n</code></pre></p> <p>Note: This command will fail at this point since we haven't mapped the container's port to the host yet. We'll fix this in the next step.</p> </li> <li> <p>Relaunch the Container with Port Mapping:    To map the container's port to the host, use:    <pre><code>podman run -p8000:8000 python-server:latest\n</code></pre></p> </li> <li> <p>Test the Server Again:    Verify the server is accessible with:    <pre><code>curl http://localhost:8000\n</code></pre></p> </li> </ol>"},{"location":"tutorials/python/#deploying-with-podman","title":"Deploying with Podman","text":"<ol> <li> <p>Create a Pod:    Deploy the application as a pod with port publishing:    <pre><code>podman play kube --publish 8000:8000 pod.yaml\n</code></pre></p> </li> <li> <p>Verify Pod is Running:    Check the status of the pod and its containers:    <pre><code>podman pod ps\npodman ps\n</code></pre></p> </li> <li> <p>Stop and Remove the Pod:    To stop and remove the pod, use:    <pre><code>podman pod stop &lt;podId&gt;\npodman pod rm &lt;podId&gt;\n</code></pre></p> </li> </ol>"},{"location":"tutorials/python/#deploying-to-openshift","title":"Deploying to OpenShift","text":"<ol> <li> <p>Create Resources in OpenShift:     Switch to the desired project and create resources:     <pre><code># Note: If you are using DevSpaces, you are already logged in your namespace due to token injection\n# For non-DevSpaces users:\n# oc login --token=&lt;your-token&gt; --server=&lt;your-server-url&gt;\n# oc project devspaces-userX\n\noc create -f pod.yaml\n</code></pre></p> </li> <li> <p>Add Service and Route:     Expose the application by creating a service and route:     <pre><code>oc create -f service.yaml\noc create -f route.yaml\n</code></pre></p> </li> <li> <p>Access the Application:     Get the route URL and access your application:     <pre><code># Get the route URL\noc get route python-server-route -o jsonpath='{.spec.host}'\n\n# Access the application using the route URL\ncurl http://$(oc get route python-server-route -o jsonpath='{.spec.host}')\n</code></pre>     You can also open the route URL in your web browser to view the application.     You can find the route URL under \"Networking\" \u2192 \"Routes\" and click it to access your application.</p> </li> <li> <p>Note on Pod Deletion:     Be aware that deleting the pod will result in the loss of the running instance.</p> </li> </ol>"},{"location":"tutorials/python/#exercises","title":"Exercises","text":""},{"location":"tutorials/python/#exercise-1-create-a-deployment-in-openshift","title":"Exercise 1: Create a Deployment in OpenShift","text":"<p>Objective: Learn how to create a deployment in OpenShift to manage your application.</p> <ol> <li> <p>Create a Deployment:    Use the following command to create a deployment for your application:    <pre><code>oc create deployment python-server --image=registry.redhat.io/ubi9/python-312 -- python3 -m http.server\n</code></pre></p> </li> <li> <p>Verify the Deployment:    Check the status of the deployment to ensure it was created successfully:    <pre><code>oc get deployments\n</code></pre></p> </li> <li> <p>Check the Pods:    Verify that pods are running as part of the deployment:    <pre><code># Note: The pod name will have a random suffix appended to it, like: python-server-5b7f8d9c7b-xyz12\noc get pods\n</code></pre></p> </li> </ol>"},{"location":"tutorials/python/#exercise-2-scale-the-deployment","title":"Exercise 2: Scale the Deployment","text":"<p>Objective: Understand how to scale a deployment to handle more traffic.</p> <ol> <li> <p>Scale the Deployment:    Increase the number of replicas to handle more traffic:    <pre><code>oc scale --replicas=3 deploy/python-server\n</code></pre></p> </li> <li> <p>Verify Scaling:    Check the status of the pods to ensure scaling was successful:    <pre><code>oc get pods\n</code></pre></p> </li> <li> <p>Test the Application:    Ensure the application is still accessible and functioning correctly:    <pre><code>curl http://$(oc get route python-server-route -o jsonpath='{.spec.host}')\n</code></pre></p> </li> </ol>"},{"location":"tutorials/python/#exercise-3-update-the-deployment-with-a-new-image","title":"Exercise 3: Update the Deployment with a New Image","text":"<p>Objective: Learn how to update a deployment with a new version of your application.</p> <ol> <li> <p>Build a New Image:    Make changes to your application and build a new image:    <pre><code>podman build -t python-server:v2 .\n</code></pre></p> </li> <li> <p>Import the Local Image to OpenShift:</p> </li> </ol> <p>For Laptop Users:</p> <p>Note: The OpenShift internal registry has been exposed just for the workshop. </p> <p>Use the following command to log in to the OpenShift internal registry:    <pre><code>podman login -u $(oc whoami) -p $(oc whoami -t) https://default-route-openshift-image-registry.apps.cluster-2jp75.2jp75.sandbox2851.opentlc.com\n</code></pre>    Tag your local image with the OpenShift registry namespace:    <pre><code>podman tag python-server:v2 default-route-openshift-image-registry.apps.cluster-2jp75.2jp75.sandbox2851.opentlc.com/devspaces-user1/python-server:v2\n</code></pre>    Push the tagged image to the OpenShift internal registry:    <pre><code>podman push default-route-openshift-image-registry.apps.cluster-2jp75.2jp75.sandbox2851.opentlc.com/devspaces-user1/python-server:v2\n</code></pre></p> <p>For DevSpaces Users:</p> <p>Use the following command to log in to the OpenShift internal registry:    <pre><code>podman login -u $(oc whoami) -p $(oc whoami -t) image-registry.openshift-image-registry.svc:5000\n</code></pre>    Tag your local image with the OpenShift registry namespace:    <pre><code>podman tag python-server:v2 image-registry.openshift-image-registry.svc:5000/devspaces-user1/python-server:v2\n</code></pre>    Push the tagged image to the OpenShift internal registry:    <pre><code>podman push image-registry.openshift-image-registry.svc:5000/devspaces-user1/python-server:v2\n</code></pre></p> <ol> <li>Update the Deployment:</li> <li> <p>Update the deployment to use the new image:      <pre><code>oc set image deployment/python-server python-312=python-server:v2 --source=imagestreamtag\n</code></pre>      &gt; Note: An imagestream tag in OpenShift is a reference to a specific version of an image within an imagestream. It allows you to manage and track different versions of container images, facilitating seamless updates and rollbacks.</p> </li> <li> <p>Verify the Update:</p> </li> <li> <p>Check the status of the deployment to ensure it updated successfully:      <pre><code>oc rollout status deployment/python-server\n</code></pre></p> </li> <li> <p>Test the Updated Application:</p> </li> <li>Verify that the updated application is running correctly:      <pre><code>curl http://$(oc get route python-server-route -o jsonpath='{.spec.host}')\n</code></pre></li> </ol>"},{"location":"tutorials/rbac/","title":"RBAC (Role-Based Access Control)","text":""},{"location":"tutorials/rbac/#tutorials","title":"Tutorials","text":"<p>This demonstrates how to set up and test role-based access control in OpenShift.</p> <p>The code examples and instructions in this tutorial are located under <code>openshift-quickstart</code> project in the <code>tutorials/rbac</code> directory.  Ensure you are in this directory before executing the commands. </p> <ol> <li> <p>Navigate to the Tutorial Directory     <pre><code># Change to the tutorials/simple directory\ncd openshift-quickstart/tutorials/rbac\n</code></pre></p> </li> <li> <p>Or open a New Terminal</p> </li> </ol>"},{"location":"tutorials/rbac/#steps","title":"Steps","text":"<ol> <li> <p>As an admin user of your namespaces, create a role that allows reading pod information:    <pre><code>oc create -f pod-reader.yaml\n</code></pre></p> </li> <li> <p>Create a RoleBinding to assign the pod-reader role to your user friend userX:    <pre><code># Replace userX with the target user and namespaceX with your namespace in the pod-reader-binding.\nsed -i 's/namespaceX/&lt;your-namespace&gt;/g' pod-reader-binding.yaml\nsed -i 's/userX/user2/g' pod-reader-binding.yaml\noc create -f pod-reader-binding.yaml\n</code></pre></p> </li> <li> <p>Ask your friend as userX and verify that you can:</p> </li> <li>View pods (<code>oc get pods</code>)</li> <li> <p>Cannot access other resources (services, routes, etc.)</p> </li> <li> <p>Add the standard view role to allow broader access:    <pre><code>oc adm policy add-role-to-user view userX -n &lt;your-namespace&gt;\n</code></pre></p> </li> <li> <p>Login as userX again and confirm that you can now:</p> </li> <li>View all basic resources in the namespace</li> <li>View pods, services, routes, configmaps, etc (no secrets).</li> <li>Cannot modify any resources (read-only access)</li> </ol>"},{"location":"tutorials/rbac/#exercises","title":"Exercises","text":""},{"location":"tutorials/rbac/#exercise-1-modify-an-existing-role","title":"Exercise 1: Modify an Existing Role","text":"<p>Objective: Learn how to modify an existing role to add or remove permissions.</p> <ol> <li> <p>Open the <code>pod-reader.yaml</code> file and add permissions to list services:      <pre><code>kind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  namespace: namespaceX\n  name: pod-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n- apiGroups: [\"\"]\n  resources: [\"services\"]\n  verbs: [\"list\"]\n</code></pre></p> </li> <li> <p>Apply the changes to update the role:    <pre><code>  oc apply -f pod-reader.yaml\n</code></pre></p> </li> <li> <p>Check the updated role to ensure the changes were applied:    <pre><code>oc get role pod-reader -o yaml\n</code></pre></p> </li> <li> <p>Verify that you user friend can now list services in addition to viewing pods:     <pre><code>oc get services\noc get pods\n</code></pre>    Ensure that you cannot modify any resources:    <pre><code># Attempting to delete a pod should fail\noc delete pod &lt;pod-name&gt;\n</code></pre>    Confirm that you still cannot access other resources like secrets:    <pre><code>oc get secrets\n</code></pre></p> </li> </ol>"},{"location":"tutorials/rbac/#exercise-3-create-a-service-account","title":"Exercise 3: Create a Service Account","text":"<p>Objective: Learn how to create a service account and bind a role to it within your own namespace.</p> <p>Note: A service account in Kubernetes is an identity that processes within a pod can use to interact with the Kubernetes API. It provides a way to control access to resources within a namespace, allowing for more granular permission management compared to using user accounts. Service accounts are particularly useful for applications running within the cluster that need to interact with the Kubernetes API.</p> <ol> <li> <p>Use the following command to create a service account named <code>pod-viewer</code> in your namespace:     <pre><code>oc create serviceaccount pod-viewer -n pod-play\n</code></pre></p> </li> <li> <p>Create a YAML file named <code>sa-rolebinding.yaml</code> to bind the <code>view</code> role to the <code>pod-viewer</code> service account:     &gt; Note: Ensure to replace <code>namespaceX</code> with your actual namespace where you want the service account and role binding to be applied.</p> <pre><code>kind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: sa-view-binding\n  namespace: namespaceX\nsubjects:\n- kind: ServiceAccount\n  name: pod-viewer\n  namespace: namespaceX\nroleRef:\n  kind: Role\n  name: view\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> </li> <li> <p>Use the following command to create the role binding for the service account:      <pre><code>oc create -f sa-rolebinding.yaml\n</code></pre></p> </li> <li> <p>Check that the service account and role binding have been created:      <pre><code>oc get serviceaccounts\noc get rolebindings\n</code></pre></p> </li> <li> <p>Use the service account to verify that it can view and list pods in the <code>namespaceX</code> namespace:      <pre><code>oc auth can-i get pods --as=system:serviceaccount:namespaceX:pod-viewer -n namespaceX\n</code></pre>    Ensure that the service account cannot modify resources:      <pre><code># Attempting to delete a pod should fail\noc auth can-i delete pod --as=system:serviceaccount:namespaceX:pod-viewer -n namespaceX\n</code></pre></p> </li> </ol>"},{"location":"tutorials/simple/","title":"Simple Container","text":""},{"location":"tutorials/simple/#tutorial","title":"Tutorial","text":"<p>This guide walks through basic container operations using Podman.</p> <p>The code examples and instructions in this tutorial are located under <code>openshift-quickstart</code> project in the <code>tutorials/simple</code> directory.  Ensure you are in this directory before executing the commands. </p> <ol> <li> <p>Navigate to the Tutorial Directory     <pre><code># Change to the tutorials/simple directory\ncd openshift-quickstart/tutorials/simple\n</code></pre></p> </li> <li> <p>Or open a New Terminal   </p> </li> <li> <p>Build the Container Image     <pre><code># Build an image tagged as 'simple:latest' from the Dockerfile in current directory\npodman build -t simple:latest .\n</code></pre></p> </li> <li> <p>Run the Container     <pre><code># Run the container in detached mode\npodman run -d simple:latest\n</code></pre></p> </li> <li> <p>View Running Containers     <pre><code># List all running containers\npodman ps -a\n</code></pre></p> </li> <li> <p>Interactive Shell Access     <pre><code># Start a new container with an interactive bash shell\npodman run -it --entrypoint /bin/bash simple:latest\n</code></pre></p> </li> <li> <p>View Container Logs, split the terminal     <pre><code># First get the container ID\npodman ps\n\n# Stream the logs from the container (-f follows the log output)\npodman logs -f &lt;containerID&gt;\n</code></pre></p> <p></p> <p>Note: Replace <code>&lt;containerID&gt;</code> with the actual container ID from <code>podman ps</code> output or <code>$(podman ps -q)</code>. </p> </li> </ol>"},{"location":"tutorials/simple/#exercies","title":"Exercies","text":""},{"location":"tutorials/simple/#exercise-1-modify-and-rebuild-the-container-image","title":"Exercise 1: Modify and Rebuild the Container Image","text":"<p>Objective: Learn how to modify a <code>Containerfile</code> and rebuild the container image.</p> <ol> <li> <p>Edit the <code>Containerfile</code>:</p> <p>Open the <code>Containerfile</code> in a text editor.</p> <p>Add a new environment variable to the image. For example, add the line: <pre><code>ENV MY_VAR=\"Hello, Podman!\"\n</code></pre></p> </li> <li> <p>Rebuild the Container Image:</p> <p>Use the following command to rebuild the image with the new changes: <pre><code>podman build -t simple:latest .\n</code></pre></p> </li> <li> <p>Verify the Changes:</p> <p>Run a new container and check if the environment variable is set: <pre><code>podman run --rm --entrypoint printenv simple:latest MY_VAR\n</code></pre></p> <p>Note: The <code>--entrypoint</code> flag overrides the default <code>echo</code> command defined in the Containerfile, allowing us to run the <code>printenv</code> command instead to verify our environment variable.</p> </li> </ol>"},{"location":"tutorials/simple/#exercise-2-create-and-use-a-volume","title":"Exercise 2: Create and Use a Volume","text":"<p>Objective: Understand how to create and use volumes to persist data.</p> <ol> <li> <p>Create a Volume:</p> <p>Create a new volume named <code>mydata</code>: <pre><code>podman volume create mydata\n</code></pre></p> </li> <li> <p>Run a Container with the Volume:</p> <p>Start a container and mount the volume to <code>/data</code> inside the container: <pre><code>podman run -it -d -v mydata:/data --entrypoint cat simple:latest\n</code></pre></p> <p>Note: The <code>-it</code> flags enable an interactive terminal session. We use <code>cat</code> as the entrypoint to keep the container running in detached mode (<code>-d</code>), since <code>cat</code> will wait for input indefinitely.</p> </li> <li> <p>Verify the Volume:</p> <p>Access the container and create a file in the <code>/data</code> directory: <pre><code>podman ps\npodman exec -it &lt;containerID&gt; touch /data/hello.txt\n</code></pre></p> </li> <li> <p>Check the Volume Content:</p> <p>Verify the file exists in the volume: <pre><code>podman run -it -v mydata:/data --entrypoint /bin/bash simple:latest\n[root@283f981a19f2 /]# ls /data\nhello.txt\n</code></pre></p> </li> </ol>"},{"location":"tutorials/simple/#exercise-3-inspect-and-manage-container-logs","title":"Exercise 3: Inspect and Manage Container Logs","text":"<p>Objective: Learn how to inspect and manage logs from a running container.</p> <ol> <li> <p>Run a Container:     Start a container that outputs logs:     <pre><code>podman run -d --entrypoint /bin/sh simple:latest -c \"while true; do echo 'Hello from container'; sleep 5; done\"\n</code></pre></p> </li> <li> <p>View Logs:</p> <p>Use the following command to stream logs from the container: <pre><code>podman logs -f &lt;containerID&gt;\n</code></pre></p> </li> <li> <p>Stop the Container:</p> <p>Stop the container after observing the logs: <pre><code>podman stop &lt;containerID&gt;\n</code></pre></p> </li> </ol>"}]}