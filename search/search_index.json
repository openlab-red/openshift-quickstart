{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenShift Quickstart","text":"<p>Welcome to the OpenShift Quickstart workshop!  This workshop is designed to provide you with a seamless development experience, whether you choose to work locally on your laptop or leverage the OpenShift DevSpaces Cloud IDE.  Both environments are equipped to help you efficiently set up and manage your development projects with ease. Follow the instructions below to get started with your preferred setup.</p>"},{"location":"#laptop","title":"Laptop","text":""},{"location":"#prerequisite-install-podman-desktop","title":"Prerequisite: Install Podman Desktop","text":"<p>Before proceeding, make sure you have Podman Desktop installed on your laptop.  You can download and install it from the official website: (https://podman-desktop.io/)[Podman Desktop].</p> <p></p>"},{"location":"#git-clone","title":"Git Clone","text":"<ol> <li>Open your terminal.</li> <li>Choose your root workspace project:<ul> <li>Decide on the directory where you want your root workspace to reside. This will be the main directory for your project files and configurations.</li> </ul> </li> <li>Navigate to the directory where you want to clone the project (e.g. <code>/projects</code>).</li> <li> <p>Run the following command to clone the Git repository:    <pre><code>cd /projects/\ngit clone https://github.com/openlab-red/openshift-quickstart.git\ngit clone https://github.com/openlab-red/openshift-quickstart-manifest.git\n</code></pre></p> </li> <li> <p>Open Visual Studio Code or your favourite IDEs:    <pre><code>code .\n</code></pre></p> </li> </ol>"},{"location":"#devspaces","title":"DevSpaces","text":""},{"location":"#using-devspaces-with-devfile","title":"Using DevSpaces with Devfile","text":"<p>OpenShift DevSpaces provides a cloud-based development environment using the configuration specified in the <code>devfile.yaml</code>. </p> <p>Follow these steps to get started:</p> <ol> <li> <p>Log into your OpenShift cluster.    </p> </li> <li> <p>Navigate to the DevSpaces dashboard.    </p> </li> <li> <p>Create a new workspace by importing this repository URL:    <pre><code>https://github.com/openlab-red/openshift-quickstart.git\n</code></pre>     DevSpaces will automatically detect and use the <code>devfile.yaml</code> at the root of the project.</p> </li> <li> <p>The devfile configures:</p> <ul> <li>A developer container with ZSH shell</li> <li>Default workspace pointing to the project's VS Code workspace</li> <li>Required environment variables and configurations</li> </ul> </li> <li> <p>Once the workspace starts:</p> <ul> <li>You'll have a fully configured development environment</li> <li>All necessary tools and dependencies will be pre-installed    </li> </ul> </li> </ol> <p>Note: The devfile inherits configurations from a parent devfile that contains base developer tooling and settings.</p>"},{"location":"setup/","title":"Workshop Cluster Setup Guide","text":"<p>This guide will walk you through the process of setting up the workshop cluster using Kustomize and OpenShift CLI (oc).</p>"},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following tools installed: - OpenShift CLI (<code>oc</code>) - Kustomize - Access to an OpenShift cluster with sufficient permissions</p>"},{"location":"setup/#setup-steps","title":"Setup Steps","text":""},{"location":"setup/#1-deploy-base-cluster-configuration","title":"1. Deploy Base Cluster Configuration","text":"<p>First, deploy the base cluster configuration using Kustomize:</p> <pre><code>kustomize build cluster/base | oc apply -f -\n</code></pre> <p>This command will: - Build the Kubernetes manifests from the base configuration - Apply them directly to your OpenShift cluster</p>"},{"location":"setup/#2-deploy-tekton-tasks","title":"2. Deploy Tekton Tasks","text":"<p>Next, deploy the required Tekton tasks for the workshop:</p> <pre><code>kustomize build cluster/tekton-tasks | oc apply -f -\n</code></pre> <p>This step sets up the CI/CD pipeline components needed for the workshop environment.</p>"},{"location":"setup/#3-deploy-devspaces-configuration","title":"3. Deploy DevSpaces Configuration","text":"<p>Finally, deploy the DevSpaces configuration with nested container support:</p> <pre><code>kustomize build devspaces/overlays/nested-container | oc apply -f -\n</code></pre> <p>This configures the development workspace environment with support for nested containers.</p>"},{"location":"setup/#verification","title":"Verification","text":"<p>After running all commands, verify your setup by: 1. Checking that all resources are in the <code>Running</code> or <code>Completed</code> state 2. Ensuring no errors are present in the cluster events 3. Verifying that DevSpaces is accessible</p>"},{"location":"setup/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues: 1. Check the logs of the deployed pods 2. Verify your cluster permissions 3. Ensure all prerequisites are properly installed 4. Check the OpenShift cluster events for any error messages</p>"},{"location":"setup/#additional-notes","title":"Additional Notes","text":"<ul> <li>Make sure to run these commands in the order specified</li> <li>Wait for each step to complete before proceeding to the next</li> <li>Monitor the cluster events during deployment for any potential issues ```</li> </ul>"},{"location":"tutorials/golang/","title":"Go API with Angular Client (using Material Design)","text":"<p>This project demonstrates a simple REST API built with Go and a corresponding Angular client application. It leverages Material Design for a user-friendly interface.</p> <p>The code examples and instructions in this tutorial are located in the <code>tutorials/golang</code> directory. Ensure you are in this directory before executing the commands.</p>"},{"location":"tutorials/golang/#features","title":"Features","text":"<ul> <li>API:</li> <li>Provides endpoints, check the openapi specification.</li> <li>Uses prepared statements for secure database interaction (assuming PostgreSQL).</li> <li>Angular Client:</li> <li>Fetches messages from the API and displays them in a list.</li> <li>Allows adding new messages.</li> <li>Implements ping functionality to check API health.</li> <li>Utilizes Material Design components for a visually appealing interface.</li> </ul>"},{"location":"tutorials/golang/#launch-the-demo","title":"Launch the demo","text":""},{"location":"tutorials/golang/#setup-database","title":"Setup database","text":"<p>First time only </p> <ul> <li> <p>Open a new Terminal on the postgresql pod.</p> <p> </p> </li> <li> <p>In the terminal launch the following command to configure the database.</p> </li> </ul> <p>Password is: <code>pass</code> </p> <pre><code>  psql -d db -U user -W -f /projects/golang/backend/db/schema.sql\n</code></pre> <p>Output sample </p> <pre><code>sh-4.4$  psql -d db -U user -W -f /projects/golang/backend/db/schema.sql\nPassword: \nCREATE TABLE\nsh-4.4$ \n</code></pre> <ul> <li>You can do the same with pgadmin which is running in your workspace, open a new terminal</li> </ul> <pre><code>echo https://$(oc get route $DEVWORKSPACE_ID-pgadmin4-5050-web -o jsonpath='{ ..spec.host }')\n</code></pre> <p></p>"},{"location":"tutorials/golang/#live-coding-of-the-go-lang-dev","title":"Live Coding of the Go Lang Dev","text":"<ul> <li>The GoLang backend use <code>air</code> for live coding, so simply launch the command to start the application.</li> </ul> <pre><code>  cd backend/app\n  air\n</code></pre> <p>Click Yes if you like to expose outside of the workspace. </p> <ul> <li>Under the <code>backend/app</code> you have the OpenApi specification and you can try directly the endpoint.</li> </ul> <p></p> <p></p>"},{"location":"tutorials/golang/#live-coding-of-frontend-app","title":"Live Coding of Frontend App","text":"<ul> <li>Launch <code>npm install</code> to download all the necessary libs.</li> </ul> <pre><code>cd frontend/app\n\nnpm install\n</code></pre> <ul> <li>Launch <code>npm start</code> to start the Live Coding.</li> </ul> <pre><code>npm start\n</code></pre>"},{"location":"tutorials/golang/#test-the-application","title":"Test the application","text":"<ul> <li>From the endpoint section now you can access the frontend application.</li> </ul> <ul> <li>Click it and now you can acces the application.</li> </ul>"},{"location":"tutorials/java/","title":"Java Stack","text":"<p>Welcome to the Java Stack repository! This repository contains sample projects that demonstrate the use of popular Java frameworks and tools. Each project is designed to help you understand the basics of building, running, and debugging Java applications using different frameworks.</p>"},{"location":"tutorials/java/#projects-included","title":"Projects Included","text":"<ol> <li>Hello World Maven Project</li> <li>A foundational Java application that outputs \"Hello, World!\" to demonstrate the basics of using Maven.</li> <li> <p>Maven Documentation</p> </li> <li> <p>Quarkus Hello World Application</p> </li> <li>A simple application leveraging Quarkus, a high-performance Java framework for cloud-native applications.</li> <li>Quarkus Documentation</li> <li> <p>Quarkus Guides</p> </li> <li> <p>Spring Boot Sample Application</p> </li> <li>A sample application using Spring Boot, a powerful framework for building production-ready applications.</li> <li>Spring Boot Documentation</li> <li>VSCode Java Documentation</li> </ol>"},{"location":"tutorials/java/#how-to-use","title":"How to Use","text":"<p>Each project comes with its own index file that provides detailed instructions on how to build, run, and debug the application. You can find these instructions in the respective project directories:</p> <ul> <li>Hello World Maven Project</li> <li>Quarkus Hello World Application</li> <li>Spring Boot Sample Application </li> </ul> <p>This repository is a great starting point for anyone looking to explore Java development with different frameworks. If you encounter any issues, please refer to the documentation linked above or seek help from the community.</p>"},{"location":"tutorials/java/helloworld/","title":"Hello World Maven Project","text":"<p>This project is a foundational Java application that outputs \"Hello, World!\" to demonstrate the basics of using Maven for building and managing Java projects.</p>"},{"location":"tutorials/java/helloworld/#tutorial-build-run-and-debug-with-visual-studio-code","title":"Tutorial: Build, Run, and Debug with Visual Studio Code","text":""},{"location":"tutorials/java/helloworld/#step-1-build-the-project","title":"Step 1: Build the Project","text":"<ol> <li>Open the terminal in VSCode (<code>Terminal -&gt; New Terminal</code>).</li> <li>Run the following command to build the project:</li> </ol> <pre><code> cd helloworld\n mvn clean install\n</code></pre>"},{"location":"tutorials/java/helloworld/#step-4-launch-the-application","title":"Step 4: Launch the Application","text":"<ol> <li>Navigate to the <code>Run and Debug</code> view by clicking on the play icon on the sidebar or pressing <code>Ctrl+Shift+D</code>.</li> <li>Select the <code>HelloWorld</code> configuration from the dropdown.</li> <li>Click the green play button to start the application.</li> </ol>"},{"location":"tutorials/java/helloworld/#step-5-debug-the-application","title":"Step 5: Debug the Application","text":"<ol> <li>Set breakpoints in your code by clicking in the gutter next to the line numbers.</li> <li>Use the <code>Run and Debug</code> view to start debugging with the <code>HelloWorld</code> configuration.</li> <li>The application will stop at your breakpoints, allowing you to inspect variables and step through the code.</li> </ol>"},{"location":"tutorials/java/helloworld/#alternative-using-command-line","title":"Alternative: Using Command Line","text":""},{"location":"tutorials/java/helloworld/#step-1-build-the-project-by-cmd","title":"Step 1: Build the Project by cmd","text":"<ol> <li>Open a terminal and navigate to the <code>helloworld</code> project directory.</li> <li>Run the following command to build the project:</li> </ol> <pre><code>mvn clean package\n</code></pre>"},{"location":"tutorials/java/helloworld/#step-2-run-the-application","title":"Step 2: Run the Application","text":"<p>After building, you can run the application using the <code>java -jar</code> command:</p> <pre><code>java -jar target/helloworld-1.0.0-SNAPSHOT.jar\n</code></pre>"},{"location":"tutorials/java/quarkus/","title":"Quarkus Hello World Application","text":"<p>Welcome to the Quarkus Hello World Application! This project leverages Quarkus, a high-performance Java framework designed for modern cloud-native applications. In this guide, you'll learn how to build, run, and debug a straightforward \"Hello World\" application using Visual Studio Code, making the most of Quarkus's capabilities.</p>"},{"location":"tutorials/java/quarkus/#building-the-application","title":"Building the Application","text":"<p>To build the application, use the following Maven command:</p> <pre><code>cd quarkus\nmvn clean package\n</code></pre> <p>This command will compile the project and package it into a JAR file located in the <code>target/quarkus-app/</code> directory.</p>"},{"location":"tutorials/java/quarkus/#running-the-application","title":"Running the Application","text":"<p>You can run the application like normal java app.</p> <pre><code>java -jar target/quarkus-app/quarkus-run.jar\n</code></pre> <p>Or you can run your application in development mode, which enables live coding, using:</p> <pre><code>mvn quarkus:dev\n</code></pre> <p>Expose the endpoint and access the application.</p> <p> </p>"},{"location":"tutorials/java/quarkus/#debugging-with-vscode","title":"Debugging with VSCode","text":"<p>It is already defined in the project. </p> <ol> <li>Configure Launch Settings:    Create a <code>launch.json</code> file in the <code>.vscode</code> directory with the following configuration:</li> </ol> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"java\",\n      \"name\": \"Quarkus Debug (Attach)\",\n      \"request\": \"attach\",\n      \"hostName\": \"localhost\",\n      \"port\": 5005\n    }\n  ]\n}\n</code></pre> <ol> <li>Start the Application in Debug Mode:    Run the application with debugging enabled:</li> </ol> <pre><code>mvn quarkus:dev\n</code></pre> <ol> <li>Attach the Debugger</li> </ol> <p>In VSCode, go to the Run and Debug view, and select \"Quarkus Debug (Attach)\" to start debugging.</p> <p></p>"},{"location":"tutorials/java/quarkus/#packaging-the-application","title":"Packaging the Application","text":"<p>To package the application execute:</p> <pre><code>mvn package\n</code></pre> <p>Run the packaged application using:</p> <pre><code>java -jar target/quarkus-app/quarkus-run.jar\n</code></pre>"},{"location":"tutorials/java/quarkus/#creating-a-native-executable","title":"Creating a Native Executable","text":"<p>You can create a native executable using:</p> <pre><code>mvn package -Pnative\n</code></pre> <p>Run the native executable with:</p> <pre><code>./target/quarkus-1.0.0-SNAPSHOT-runner -Dquarkus.http.port=8081\n</code></pre>"},{"location":"tutorials/java/quarkus/#building-the-container","title":"Building the Container","text":"<p>To build a container for your Quarkus application, follow these steps:</p>"},{"location":"tutorials/java/quarkus/#deploy-external-postgresql-database","title":"Deploy external postgresql database","text":"<p>To deploy it, you can simply run the Task <code>099 - Install Postgres with OpenShift</code> from the Task Manager.</p>"},{"location":"tutorials/java/quarkus/#steps","title":"Steps","text":"<ol> <li>Ensure the Application is Packaged:    Before building the Docker image, make sure your application is packaged. You can do this by running:</li> </ol> <pre><code>mvn package -Dquarkus.profile=prod\n</code></pre> <ol> <li>Build the Image:    Use the following command to build the image. This command uses the Dockerfile located at <code>src/main/docker/Dockerfile.jvm</code>:</li> </ol> <pre><code>podman build -f src/main/docker/Dockerfile.jvm -t quarkus:latest .\n</code></pre> <ol> <li>Run the Docker Container:    Once the image is built, you can run the container using:</li> </ol> <pre><code>podman_run quarkus:latest -p 8080:8080 \n</code></pre> <ol> <li>Deploy with the helm chart:</li> </ol> <pre><code>podman tag quarkus:latest quay.io/mmascia/stack-java/quarkus:latest\npodman push quay.io/mmascia/stack-java/quarkus:latest\ncd ..\nhelm upgrade --install quarkus helm/java-app\n</code></pre> <p>These steps will help you build and run your Quarkus application in a container, allowing for easy deployment and testing.</p>"},{"location":"tutorials/java/quarkus/#database","title":"Database","text":"<p>The Quarkus application supports multiple database configurations. You can run the application with different databases using the following methods:</p>"},{"location":"tutorials/java/quarkus/#prerequisites-for-database-containers","title":"Prerequisites for Database Containers","text":"<p>Before running the application with a specific database profile, ensure that the respective database container is up and running. You can use the following commands to start the database containers:</p> <ul> <li>PostgreSQL: </li> </ul> <p>Note: PostgreSQL is already running as a sidecar container in the workspace. If you need to start it manually, execute the following command:</p> <ul> <li>MySQL:    To start the MySQL container, execute the following command:</li> </ul> <pre><code>podman run --name mysql -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=db -p 3306:3306 registry.redhat.io/rhel8/mysql-80:latest\n</code></pre> <ul> <li>MongoDB:    To start the MongoDB container, execute the following command:</li> </ul> <pre><code>podman run --name mongodb -v /tmp/:/bitnami -e MONGODB_ROOT_USER=user -e MONGODB_ROOT_PASSWORD=pass -e MONGODB_REPLICA_SET_MODE=primary -e MONGODB_REPLICA_SET_NAME=rs0 -e MONGODB_REPLICA_SET_KEY=replicakey123456 -e MONGODB_DATABASE=db -p 27017:27017 docker.io/bitnami/mongodb:latest\n</code></pre> <p>Ensure that the respective database container is running before starting the application with the desired profile.</p>"},{"location":"tutorials/java/quarkus/#launching-the-application","title":"Launching the Application","text":"<p>To launch the Quarkus application with a specific database profile, use the following commands:</p> <ul> <li>PostgreSQL (Default):   Run the application with the default PostgreSQL profile:</li> </ul> <pre><code>mvn quarkus:dev\n</code></pre> <ul> <li>MySQL:   To run the application with MySQL, specify the MySQL profile:</li> </ul> <pre><code>mvn quarkus:dev -Dquarkus.profile=mysql\n</code></pre> <ul> <li>MongoDB:   To run the application with MongoDB, specify the MongoDB profile:</li> </ul> <pre><code>mvn quarkus:dev -Dquarkus.profile=mongodb\n</code></pre> <p>These commands will start the Quarkus application in development mode with the specified database configuration.</p>"},{"location":"tutorials/java/quarkus/#additional-resources","title":"Additional Resources","text":"<ul> <li>Quarkus Official Documentation</li> <li>Quarkus Guides</li> </ul> <p>This guide should help you get started with building, running, and debugging a Quarkus application using VSCode. If you encounter any issues, refer to the Quarkus documentation or seek help from the community.</p>"},{"location":"tutorials/java/springboot/","title":"Spring Boot Sample Application","text":"<p>Welcome to the Spring Boot Sample Application! This project leverages Spring Boot, a powerful Java framework for building production-ready applications. In this guide, you'll learn how to build, run, and debug a Spring Boot application using Visual Studio Code, making the most of Spring Boot's capabilities.</p>"},{"location":"tutorials/java/springboot/#building-the-application","title":"Building the Application","text":"<p>To build the application, use the following Maven command:</p> <pre><code>cd springboot\nmvn clean package\n</code></pre> <p>This command will compile the project and package it into a JAR file located in the <code>target/</code> directory.</p>"},{"location":"tutorials/java/springboot/#running-the-application","title":"Running the Application","text":"<p>You can run the application like normal java app.</p> <pre><code>java -jar target/boot-0.0.1-SNAPSHOT.jar\n</code></pre> <p>Or you can run your application in development mode, which enables live coding, using:</p> <pre><code>mvn spring-boot:run\n</code></pre> <p>Expose the endpoint and access the application.</p> <p></p>"},{"location":"tutorials/java/springboot/#debugging-with-vscode","title":"Debugging with VSCode","text":"<p>It is already defined in the project. </p> <ol> <li>Run in VSCode:</li> <li>Open the project in VSCode.</li> <li>Navigate to the <code>BootApplication.java</code> file.</li> <li>Click on the <code>Run</code> button above the <code>main</code> method or use the <code>Run</code> menu.</li> </ol>"},{"location":"tutorials/java/springboot/#debugging-the-application","title":"Debugging the Application","text":"<ol> <li>Debug in VSCode:</li> <li>Set breakpoints in your Java files.</li> <li>Open the <code>Run and Debug</code> panel in VSCode (Ctrl+Shift+D).</li> <li>Click on <code>Run and Debug</code> and select <code>Java</code> environment.</li> <li>The application will start in debug mode, and execution will pause at your breakpoints.</li> </ol>"},{"location":"tutorials/java/springboot/#building-the-container","title":"Building the Container","text":"<p>To build a container for your Quarkus application, follow these steps:</p>"},{"location":"tutorials/java/springboot/#deploy-external-postgresql-database","title":"Deploy external postgresql database","text":"<p>To deploy it, you can simply run the Task <code>099 - Install Postgres with OpenShift</code> from the Task Manager.</p>"},{"location":"tutorials/java/springboot/#steps","title":"Steps","text":"<ol> <li>Ensure the Application is Packaged:    Before building the Docker image, make sure your application is packaged. You can do this by running:</li> </ol> <pre><code>mvn package\n</code></pre> <ol> <li>Build the Image:    Use the following command to build the image. This command uses the Dockerfile located at <code>src/main/docker/Dockerfile.jvm</code>:</li> </ol> <pre><code>podman build -f src/main/docker/Dockerfile.jvm -t boot:latest .\n</code></pre> <ol> <li>Run the Docker Container:    Once the image is built, you can run the container using:</li> </ol> <pre><code>podman_run boot:latest -p 8080:8080 \n</code></pre> <ol> <li>Deploy with the helm chart:</li> </ol> <pre><code>podman tag boot:latest quay.io/mmascia/stack-java/boot:latest\npodman push quay.io/mmascia/stack-java/boot:latest\ncd ..\nhelm upgrade --install boot helm/java-app -f helm/java-app/values-boot.yaml\n</code></pre> <p>These steps will help you build and run your Spring Boot application in a container, allowing for easy deployment and testing.</p> <p>// ... existing content ...</p>"},{"location":"tutorials/java/springboot/#database","title":"Database","text":"<p>The application supports multiple database configurations through Spring profiles. You can run the application with different databases using the following methods:</p>"},{"location":"tutorials/java/springboot/#prerequisites-for-database-containers","title":"Prerequisites for Database Containers","text":"<p>Before running the application with a specific database profile, ensure that the respective database container is up and running. You can use the following commands to start the database containers:</p> <ul> <li>PostgreSQL: </li> </ul> <p>Note: PostgreSQL is already running as a sidecar container in the workspace. If you need to start it manually, execute the following command:</p> <ul> <li>MySQL:    To start the MySQL container, execute the following command:</li> </ul> <pre><code>podman run --name mysql -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=db -p 3306:3306 registry.redhat.io/rhel8/mysql-80:latest\n</code></pre> <ul> <li>MongoDB:    To start the MongoDB container, execute the following command:</li> </ul> <pre><code>podman run --name mongodb -v /tmp/:/bitnami -e MONGODB_ROOT_USER=user -e MONGODB_ROOT_PASSWORD=pass -e MONGODB_REPLICA_SET_MODE=primary -e MONGODB_REPLICA_SET_NAME=rs0 -e MONGODB_REPLICA_SET_KEY=replicakey123456 -e MONGODB_DATABASE=db -p 27017:27017 docker.io/bitnami/mongodb:latest\n</code></pre> <p>Ensure that the respective database container is running before starting the application with the desired profile.</p>"},{"location":"tutorials/java/springboot/#postgresql-default","title":"PostgreSQL (Default)","text":"<p>The default profile uses PostgreSQL. Run the application with either:</p> <pre><code>mvn spring-boot:run\n</code></pre> <p>Or explicitly specify the PostgreSQL profile:</p> <pre><code>mvn spring-boot:run\n</code></pre>"},{"location":"tutorials/java/springboot/#mysql","title":"MySQL","text":"<p>To run the application with MySQL:</p> <pre><code>mvn spring-boot:run -Dspring-boot.run.profiles=mysql\n</code></pre>"},{"location":"tutorials/java/springboot/#mongodb","title":"MongoDB","text":"<p>To run the application with MongoDB:</p> <pre><code>mvn spring-boot:run -Dspring-boot.run.profiles=mongodb\n</code></pre>"},{"location":"tutorials/java/springboot/#additional-resources","title":"Additional Resources","text":"<ul> <li>Spring Boot Documentation</li> <li>VSCode Java Documentation</li> </ul>"},{"location":"tutorials/java/springboot/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure all dependencies are correctly installed.</li> <li>Check the <code>pom.xml</code> for any missing dependencies or plugins.</li> </ul>"},{"location":"tutorials/js/","title":"NodeJs Express API with Angular Client (using Material Design)","text":"<p>This project demonstrates a simple REST API built with Express NodeJS and a corresponding Angular client application. It leverages Material Design for a user-friendly interface.</p>"},{"location":"tutorials/js/#features","title":"Features","text":"<ul> <li>API:</li> <li>Provides endpoints, check the openapi specification.</li> <li>Uses prepared statements for secure database interaction (assuming PostgreSQL).</li> <li>Angular Client:</li> <li>Fetches messages from the API and displays them in a list.</li> <li>Allows adding new messages.</li> <li>Implements ping functionality to check API health.</li> <li>Utilizes Material Design components for a visually appealing interface.</li> </ul>"},{"location":"tutorials/js/#launch-the-demo","title":"Launch the demo","text":""},{"location":"tutorials/js/#setup-database","title":"Setup database","text":"<p>First time only </p> <ul> <li> <p>Open a new Terminal on the postgresql pod.</p> <p> </p> </li> <li> <p>In the terminal launch the following command to configure the database.</p> </li> </ul> <p>Password is: <code>pass</code> </p> <pre><code>  psql -d db -U user -W -f /projects/js/backend/db/schema.sql\n</code></pre> <p>Output sample </p> <pre><code>sh-4.4$  psql -d db -U user -W -f /projects/js/backend/db/schema.sql\nPassword: \nCREATE TABLE\nsh-4.4$ \n</code></pre> <ul> <li>You can do the same with pgadmin which is running in your workspace, open a new terminal</li> </ul> <pre><code>echo https://$(oc get route $DEVWORKSPACE_ID-pgadmin4-5050-web -o jsonpath='{ ..spec.host }')\n</code></pre> <p></p>"},{"location":"tutorials/js/#live-coding-of-the-nodejs-server","title":"Live Coding of the NodeJs server","text":"<ul> <li>Launch <code>npm install</code> to download all the necessary libs.</li> </ul> <pre><code>cd backend/app\n\nnpm install\n</code></pre> <ul> <li>The nodejs backend use <code>nodemon</code> for live coding, so simply launch the command to start the application.</li> </ul> <pre><code>  cd backend/app\n  npm run startdev\n</code></pre> <p>Click Yes if you like to expose outside of the workspace. </p> <ul> <li>Under the <code>backend/app</code> you have the OpenApi specification and you can try directly the endpoint.</li> </ul> <p></p> <p></p>"},{"location":"tutorials/js/#live-coding-of-frontend-app","title":"Live Coding of Frontend App","text":"<ul> <li>Launch <code>npm install</code> to download all the necessary libs.</li> </ul> <pre><code>cd frontend/app\n\nnpm install\n</code></pre> <ul> <li>Launch <code>npm start</code> to start the Live Coding.</li> </ul> <pre><code>npm start\n</code></pre>"},{"location":"tutorials/js/#test-the-application","title":"Test the application","text":"<ul> <li>From the endpoint section now you can access the frontend application.</li> </ul> <ul> <li>Click it and now you can acces the application.</li> </ul>"},{"location":"tutorials/networkpolicy/","title":"Network Policy","text":"<ol> <li> <p>Test communication, everything is allowed inside a namespace.</p> <p>From the python pod</p> <pre><code>curl -I http://openshift-quickstart\n</code></pre> <p>From the java pod</p> <pre><code>curl -I http://python-server-service:8000\n</code></pre> </li> <li> <p>Apply the deny policy to openshift-quickstart</p> <p><code>oc create -f deny.yaml</code></p> </li> <li> <p>Test from the python pod.</p> <p><code>curl -I http://openshift-quickstart -v</code></p> </li> <li> <p>Create the allow policy to openshift-quickstart`</p> <p><code>oc create -f allow.yaml</code></p> </li> <li> <p>Test Again</p> <p><code>curl -I http://openshift-quickstart</code></p> </li> <li> <p>Create a new python pod changing name and labels</p> <pre><code>---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: python-server-second\n  labels:\n    app: python-server-second\nspec:\n  containers:\n  - name: python-server-container\n    image: registry.access.redhat.com/ubi9/python-311\n    ports:\n    - containerPort: 8000\n    command: [\"python3\", \"-m\", \"http.server\"]\n    resources:\n      limits:\n        cpu: \"0.5\"\n        memory: \"512Mi\"\n      requests:\n        cpu: \"0.2\"\n        memory: \"256Mi\"\n    livenessProbe:\n      httpGet:\n        path: /\n        port: 8000\n      initialDelaySeconds: 3\n      periodSeconds: 3\n</code></pre> </li> <li> <p>Test from this new pod</p> <p><code>curl -I http://openshift-quickstart -v</code></p> </li> </ol>"},{"location":"tutorials/pipeline/","title":"Pipeline Setup","text":"<p>This tutorial will guide you through the process of setting up and executing a pipeline using the provided Helm chart. We will cover creating a pipeline and PVC, launching a PipelineRun, and setting up event listeners and triggers.</p>"},{"location":"tutorials/pipeline/#steps","title":"Steps","text":""},{"location":"tutorials/pipeline/#1-install-the-pipeline-using-helm","title":"1. Install the Pipeline using Helm","text":"<p>First, we need to install the pipeline using the Helm chart. The release name should be the type of the pipeline (e.g., <code>java</code>, <code>golang</code>, <code>nodejs</code>), and the target namespace should be your user namespace (<code>user1</code>) or <code>devspaces-user1</code> if using DevSpaces.</p>"},{"location":"tutorials/pipeline/#15-link-the-registry-credentials-to-the-pipeline-service-account","title":"1.5. Link the Registry Credentials to the Pipeline Service Account","text":"<p>Before launching the pipeline, ensure that the pipeline service account has the necessary credentials to pull images from the registry. Use the following command to link the <code>registry-credentials</code> secret to the <code>pipeline</code> service account:</p> <pre><code>oc secrets link --for=mount pipeline registry-credentials\n</code></pre> <ol> <li>Install the Helm Chart:</li> </ol> <p>Use the following command to install the Helm chart. Replace <code>&lt;pipeline-type&gt;</code> with <code>java</code>, <code>golang</code>, or <code>nodejs</code>, and <code>&lt;namespace&gt;</code> with <code>user1</code> or <code>devspaces-user1</code>.</p> <pre><code>cd gitops/pipeline\n\nhelm install &lt;pipeline-type&gt; helm/pipeline --namespace &lt;namespace&gt;\n</code></pre>"},{"location":"tutorials/pipeline/#2-launch-the-pipelinerun","title":"2. Launch the PipelineRun","text":"<p>To execute the pipeline, we need to create a PipelineRun using the OpenShift UI.</p> <ol> <li> <p>Create the PipelineRun:</p> </li> <li> <p>Navigate to the OpenShift Console and log in with your credentials.</p> </li> <li>Go to the \"Pipelines\" section in your project.</li> <li>Click on the target pipeline from the list.</li> <li> <p>Click Actions and \"Start\" button.</p> </li> <li> <p>Select Workspaces:</p> </li> </ol> <p>Before starting the PipelineRun, ensure that you have selected the appropriate workspaces and PVCs. This is crucial for the pipeline to access necessary resources and credentials.</p> <ul> <li> <p>Select Workspaces:</p> <ul> <li>Ensure the following workspaces are selected:</li> <li><code>&lt;pipeline-type&gt;-ws</code></li> <li><code>&lt;pipeline-type&gt;-resource-ws</code></li> <li><code>&lt;pipeline-type&gt;-dockerconfig</code></li> <li><code>&lt;pipeline-type&gt;-git-credentials</code></li> </ul> </li> <li> <p>Select PVCs:</p> <ul> <li>Ensure the following PVCs are selected:</li> <li><code>&lt;pipeline-type&gt;-ws</code> (replace with actual PVC name)</li> <li><code>&lt;pipeline-type&gt;-resource-ws</code> (replace with actual PVC name)</li> </ul> </li> <li> <p>Link Docker and GitHub Credentials:</p> <ul> <li>Ensure that the Docker and GitHub credentials are linked to the pipeline service account:</li> <li><code>registry-credentials</code> for Docker</li> <li><code>git-credentials</code> for GitHub</li> </ul> </li> </ul> <p>After selecting the workspaces, PVCs, and linking the credentials, proceed to the next step.</p> <ol> <li>Click \"Start\":</li> </ol> <p>Once all selections are made, click the \"Start\" button to initiate the PipelineRun.</p>"},{"location":"tutorials/python/","title":"Deploying and Testing a Python server","text":""},{"location":"tutorials/python/#tutorial","title":"Tutorial","text":"<p>The code examples and instructions in this tutorial are located under <code>openshift-quickstart</code> project in the <code>tutorials/python</code> directory.  Ensure you are in this directory before executing the commands. </p> <ol> <li> <p>Navigate to the Tutorial Directory     <pre><code># Change to the tutorials/simple directory\ncd openshift-quickstart/tutorials/python\n</code></pre></p> </li> <li> <p>Or open a New Terminal</p> </li> </ol>"},{"location":"tutorials/python/#building-the-container-image","title":"Building the Container Image","text":"<ol> <li>Build the Container Image:    Use the following command to build the container image for the Python server:    <pre><code>podman build -t python-server:latest .\n</code></pre></li> </ol>"},{"location":"tutorials/python/#running-the-container","title":"Running the Container","text":"<ol> <li> <p>Run the Container:    Start the container using the image you just built:    <pre><code>podman run python-server:latest\n</code></pre></p> </li> <li> <p>Verify the Container is Running:    Check the status of the running container with:    <pre><code>podman ps\n</code></pre></p> </li> </ol>"},{"location":"tutorials/python/#testing-the-server","title":"Testing the Server","text":"<ol> <li> <p>Test the Server:    Ensure the server is responding by executing:    <pre><code>curl http://localhost:8000\n</code></pre></p> </li> <li> <p>Relaunch the Container with Port Mapping:    To map the container's port to the host, use:    <pre><code>podman run -p8000:8000 python-server:latest\n</code></pre></p> </li> <li> <p>Test the Server Again:    Verify the server is accessible with:    <pre><code>curl http://localhost:8000\n</code></pre></p> </li> </ol>"},{"location":"tutorials/python/#deploying-with-podman-and-openshift","title":"Deploying with Podman and OpenShift","text":"<ol> <li> <p>Create a Pod:    Deploy the application as a pod with port publishing:    <pre><code>podman play kube --publish 8000:8000 pod.yaml\n</code></pre></p> </li> <li> <p>Verify Pod is Running:    Check the status of the pod and its containers:    <pre><code>podman pod ps\npodman ps\n</code></pre></p> </li> <li> <p>Stop and Remove the Pod:    To stop and remove the pod, use:    <pre><code>podman pod stop &lt;podId&gt;\npodman pod rm &lt;podId&gt;\n</code></pre></p> </li> </ol>"},{"location":"tutorials/python/#deploying-to-openshift","title":"Deploying to OpenShift","text":"<ol> <li> <p>Create Resources in OpenShift:     Switch to the desired project and create resources:     <pre><code>oc login --token=&lt;your-token&gt; --server=&lt;your-server-url&gt;\noc new-project pod-play\noc create -f pod.yaml -n pod-play\n</code></pre></p> </li> <li> <p>Add Service and Route:     Expose the application by creating a service and route:     <pre><code>oc create -f service.yaml -n pod-play\noc create -f route.yaml -n pod-play\n</code></pre></p> </li> <li> <p>Note on Pod Deletion:     Be aware that deleting the pod will result in the loss of the running instance.</p> </li> </ol>"},{"location":"tutorials/python/#exercises","title":"Exercises","text":""},{"location":"tutorials/python/#exercise-1-create-a-deployment-in-openshift","title":"Exercise 1: Create a Deployment in OpenShift","text":"<p>Objective: Learn how to create a deployment in OpenShift to manage your application.</p> <ol> <li>Create a Deployment:</li> <li> <p>Use the following command to create a deployment for your application:      <pre><code>oc create deployment python-server --image=registry.redhat.io/ubi9/python-312 -n pod-play\n</code></pre></p> </li> <li> <p>Verify the Deployment:</p> </li> <li> <p>Check the status of the deployment to ensure it was created successfully:      <pre><code>oc get deployments -n pod-play\n</code></pre></p> </li> <li> <p>Check the Pods:</p> </li> <li>Verify that pods are running as part of the deployment:      <pre><code>oc get pods -n pod-play\n</code></pre></li> </ol>"},{"location":"tutorials/python/#exercise-2-scale-the-deployment","title":"Exercise 2: Scale the Deployment","text":"<p>Objective: Understand how to scale a deployment to handle more traffic.</p> <ol> <li>Scale the Deployment:</li> <li> <p>Increase the number of replicas to handle more traffic:      <pre><code>oc scale deployment/python-server --replicas=3 -n pod-play\n</code></pre></p> </li> <li> <p>Verify Scaling:</p> </li> <li> <p>Check the status of the pods to ensure scaling was successful:      <pre><code>oc get pods -n pod-play\n</code></pre></p> </li> <li> <p>Test the Application:</p> </li> <li>Ensure the application is still accessible and functioning correctly:      <pre><code>curl http://&lt;route-url&gt;\n</code></pre></li> </ol>"},{"location":"tutorials/python/#exercise-3-update-the-deployment-with-a-new-image","title":"Exercise 3: Update the Deployment with a New Image","text":"<p>Objective: Learn how to update a deployment with a new version of your application.</p> <ol> <li>Build a New Image:</li> <li> <p>Make changes to your application and build a new image:      <pre><code>podman build -t python-server:v2 .\n</code></pre></p> </li> <li> <p>Update the Deployment:</p> </li> <li> <p>Update the deployment to use the new image:      <pre><code>oc set image deployment/python-server python-server=python-server:v2 -n pod-play\n</code></pre></p> </li> <li> <p>Verify the Update:</p> </li> <li> <p>Check the status of the deployment to ensure it updated successfully:      <pre><code>oc rollout status deployment/python-server -n pod-play\n</code></pre></p> </li> <li> <p>Test the Updated Application:</p> </li> <li>Verify that the updated application is running correctly:      <pre><code>curl http://&lt;route-url&gt;\n</code></pre></li> </ol>"},{"location":"tutorials/rbac/","title":"RBAC (Role-Based Access Control)","text":""},{"location":"tutorials/rbac/#tutorials","title":"Tutorials","text":"<p>The code examples and instructions in this tutorial are located in the <code>tutorials/rbac</code> directory. Ensure you are in this directory before executing the commands.</p> <p>This guide demonstrates how to set up and test role-based access control in OpenShift.</p>"},{"location":"tutorials/rbac/#steps","title":"Steps","text":"<ol> <li> <p>Create the Pod Reader Role    As an admin user, create a role that allows reading pod information:    <pre><code>oc create -f pod-reader.yaml -n pod-play\n</code></pre></p> </li> <li> <p>Bind the Role to a User    Create a RoleBinding to assign the pod-reader role to user1:    <pre><code>oc create -f pod-reader-binding.yaml -n pod-play\n</code></pre></p> </li> <li> <p>Test Limited Access    Login as user1 and verify that you can:</p> </li> <li>View pods (<code>oc get pods</code>)</li> <li> <p>Cannot access other resources (services, routes, etc.)</p> </li> <li> <p>Grant Additional Permissions    Add the standard view role to allow broader access:    <pre><code>oc adm policy add-role-to-user view user1 -n pod-play\n</code></pre></p> </li> <li> <p>Verify Extended Access    Login as user1 again and confirm that you can now:</p> </li> <li>View all basic resources in the namespace</li> <li>View pods, services, routes, configmaps, etc.</li> <li>Cannot modify any resources (read-only access)</li> </ol>"},{"location":"tutorials/rbac/#exercises","title":"Exercises","text":""},{"location":"tutorials/rbac/#exercise-1-create-a-custom-role","title":"Exercise 1: Create a Custom Role","text":"<p>Objective: Learn how to create a custom role with specific permissions.</p> <ol> <li>Define a Custom Role:</li> <li> <p>Create a YAML file named <code>custom-role.yaml</code> with the following content to define a role that allows listing and watching pods:      <pre><code>kind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  namespace: pod-play\n  name: custom-pod-watcher\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"list\", \"watch\"]\n</code></pre></p> </li> <li> <p>Create the Role:</p> </li> <li> <p>Apply the role using the following command:      <pre><code>oc create -f custom-role.yaml -n pod-play\n</code></pre></p> </li> <li> <p>Verify the Role:</p> </li> <li>Check that the role has been created:      <pre><code>oc get roles -n pod-play\n</code></pre></li> </ol>"},{"location":"tutorials/rbac/#exercise-2-modify-an-existing-role","title":"Exercise 2: Modify an Existing Role","text":"<p>Objective: Learn how to modify an existing role to add or remove permissions.</p> <ol> <li>Edit the Pod Reader Role:</li> <li> <p>Open the <code>pod-reader.yaml</code> file and add permissions to list services:      <pre><code>kind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  namespace: pod-play\n  name: pod-reader\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n- apiGroups: [\"\"]\n  resources: [\"services\"]\n  verbs: [\"list\"]\n</code></pre></p> </li> <li> <p>Update the Role:</p> </li> <li> <p>Apply the changes to update the role:      <pre><code>oc apply -f pod-reader.yaml -n pod-play\n</code></pre></p> </li> <li> <p>Verify the Changes:</p> </li> <li>Check the updated role to ensure the changes were applied:      <pre><code>oc get role pod-reader -o yaml -n pod-play\n</code></pre></li> </ol>"},{"location":"tutorials/rbac/#exercise-3-create-a-rolebinding-for-a-group","title":"Exercise 3: Create a RoleBinding for a Group","text":"<p>Objective: Learn how to bind a role to a group of users.</p> <ol> <li>Create a Group:</li> <li> <p>Add users to a group named <code>dev-team</code>:      <pre><code>oc adm groups new dev-team\noc adm groups add-users dev-team user2 user3\n</code></pre></p> </li> <li> <p>Create a RoleBinding:</p> </li> <li> <p>Create a YAML file named <code>group-rolebinding.yaml</code> to bind the <code>view</code> role to the <code>dev-team</code> group:      <pre><code>kind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: view-binding\n  namespace: pod-play\nsubjects:\n- kind: Group\n  name: dev-team\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: view\n  apiGroup: rbac.authorization.k8s.io\n</code></pre></p> </li> <li> <p>Apply the RoleBinding:</p> </li> <li> <p>Use the following command to create the role binding:      <pre><code>oc create -f group-rolebinding.yaml -n pod-play\n</code></pre></p> </li> <li> <p>Verify the RoleBinding:</p> </li> <li>Check that the role binding has been created:      <pre><code>oc get rolebindings -n pod-play\n</code></pre></li> </ol>"},{"location":"tutorials/simple/","title":"Simple Container","text":""},{"location":"tutorials/simple/#tutorial","title":"Tutorial","text":"<p>This guide walks through basic container operations using Podman.</p> <p>The code examples and instructions in this tutorial are located under <code>openshift-quickstart</code> project in the <code>tutorials/simple</code> directory.  Ensure you are in this directory before executing the commands. </p> <ol> <li> <p>Navigate to the Tutorial Directory     <pre><code># Change to the tutorials/simple directory\ncd openshift-quickstart/tutorials/simple\n</code></pre></p> </li> <li> <p>Or open a New Terminal   </p> </li> <li> <p>Build the Container Image     <pre><code># Build an image tagged as 'simple:latest' from the Dockerfile in current directory\npodman build -t simple:latest .\n</code></pre></p> </li> <li> <p>Run the Container     <pre><code># Run the container in detached mode\npodman run -d simple:latest\n</code></pre></p> </li> <li> <p>View Running Containers     <pre><code># List all running containers\npodman ps -a\n</code></pre></p> </li> <li> <p>Interactive Shell Access     <pre><code># Start a new container with an interactive bash shell\npodman run -it --entrypoint /bin/bash simple:latest\n</code></pre></p> </li> <li> <p>View Container Logs, split the terminal     <pre><code># First get the container ID\npodman ps\n\n# Stream the logs from the container (-f follows the log output)\npodman logs -f &lt;containerID&gt;\n</code></pre></p> <p></p> <p>Note: Replace <code>&lt;containerID&gt;</code> with the actual container ID from <code>podman ps</code> output or <code>$(podman ps -q)</code>. </p> </li> </ol>"},{"location":"tutorials/simple/#exercies","title":"Exercies","text":""},{"location":"tutorials/simple/#exercise-1-modify-and-rebuild-the-container-image","title":"Exercise 1: Modify and Rebuild the Container Image","text":"<p>Objective: Learn how to modify a <code>Containerfile</code> and rebuild the container image.</p> <ol> <li> <p>Edit the <code>Containerfile</code>:</p> <p>Open the <code>Containerfile</code> in a text editor.</p> <p>Add a new environment variable to the image. For example, add the line: <pre><code>ENV MY_VAR=\"Hello, Podman!\"\n</code></pre></p> </li> <li> <p>Rebuild the Container Image:</p> <p>Use the following command to rebuild the image with the new changes: <pre><code>podman build -t simple:latest .\n</code></pre></p> </li> <li> <p>Verify the Changes:</p> <p>Run a new container and check if the environment variable is set: <pre><code>podman run --rm --entrypoint printenv simple:latest MY_VAR\n</code></pre></p> <p>Note: The <code>--entrypoint</code> flag overrides the default <code>echo</code> command defined in the Containerfile, allowing us to run the <code>printenv</code> command instead to verify our environment variable.</p> </li> </ol>"},{"location":"tutorials/simple/#exercise-2-create-and-use-a-volume","title":"Exercise 2: Create and Use a Volume","text":"<p>Objective: Understand how to create and use volumes to persist data.</p> <ol> <li> <p>Create a Volume:</p> <p>Create a new volume named <code>mydata</code>: <pre><code>podman volume create mydata\n</code></pre></p> </li> <li> <p>Run a Container with the Volume:</p> <p>Start a container and mount the volume to <code>/data</code> inside the container: <pre><code>podman run -it -d -v mydata:/data --entrypoint cat simple:latest\n</code></pre></p> <p>Note: The <code>-it</code> flags enable an interactive terminal session. We use <code>cat</code> as the entrypoint to keep the container running in detached mode (<code>-d</code>), since <code>cat</code> will wait for input indefinitely.</p> </li> <li> <p>Verify the Volume:</p> <p>Access the container and create a file in the <code>/data</code> directory: <pre><code>podman ps\npodman exec -it &lt;containerID&gt; touch /data/hello.txt\n</code></pre></p> </li> <li> <p>Check the Volume Content:</p> <p>Verify the file exists in the volume: <pre><code>podman run -it -v mydata:/data --entrypoint /bin/bash simple:latest\n[root@283f981a19f2 /]# ls /data\nhello.txt\n</code></pre></p> </li> </ol>"},{"location":"tutorials/simple/#exercise-3-inspect-and-manage-container-logs","title":"Exercise 3: Inspect and Manage Container Logs","text":"<p>Objective: Learn how to inspect and manage logs from a running container.</p> <ol> <li> <p>Run a Container:     Start a container that outputs logs:     <pre><code>podman run -d --entrypoint /bin/sh simple:latest -c \"while true; do echo 'Hello from container'; sleep 5; done\"\n</code></pre></p> </li> <li> <p>View Logs:</p> <p>Use the following command to stream logs from the container: <pre><code>podman logs -f &lt;containerID&gt;\n</code></pre></p> </li> <li> <p>Stop the Container:</p> <p>Stop the container after observing the logs: <pre><code>podman stop &lt;containerID&gt;\n</code></pre></p> </li> </ol>"}]}